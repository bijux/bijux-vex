{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"bijux-vex \u2014 vector execution engine with explicit determinism","text":"<p>bijux-vex executes vector workloads under contracts. Deterministic runs are replayable; non-deterministic runs are bounded, audited, and comparable. Nothing is implicit: no silent defaults, retries, or randomness.</p>"},{"location":"#what-bijux-vex-is","title":"What bijux-vex is","text":"<p>Vector execution engine with explicit determinism contracts. Deterministic paths are bit-stable and replayable; non-deterministic paths (ANN) are supported but experimental and always emit approximation + randomness provenance.</p>"},{"location":"#what-bijux-vex-is-not","title":"What bijux-vex is not","text":"<ul> <li>Not a vector DB or storage layer.</li> <li>Not an embedding or RAG framework.</li> <li>Not a serving platform with SLAs.</li> </ul>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Start here (single onboarding path): user/start_here.md</li> <li>Docs home: https://bijux.github.io/bijux-vex/</li> <li>Concepts: overview/concepts.md</li> <li>API: api/index.md and <code>api/v1/schema.yaml</code> (canonical contract)</li> <li>Examples: examples/overview.md</li> <li>Changelog: changelog.md</li> <li>Not a vector DB: user/not_a_vdb.md</li> </ul>"},{"location":"#reading-order-guaranteed","title":"Reading order (guaranteed)","text":"<p>1) Start with user/start_here.md for the problem, fit, and next steps. 2) Then overview/concepts.md for execution vs storage and determinism vs non-determinism. 3) Then spec/system_contract.md and spec/execution_contracts.md for the normative rules. 4) Run examples/overview.md for deterministic and ANN flows. 5) Consult api/index.md and <code>api/v1/schema.yaml</code> when integrating. Everything else is reference or maintainer material.</p>"},{"location":"#start-here","title":"Start here","text":"<p>Read <code>docs/user/start_here.md</code>. It explains the problem, when to use bijux-vex, deterministic vs non-deterministic execution, and where to go next.</p>"},{"location":"#minimal-example-cli-10-lines","title":"Minimal example (CLI, 10 lines)","text":"<pre><code>bijux vex create --name demo\nbijux vex ingest --documents doc.txt --vectors [[0,1,0]]\nbijux vex artifact --artifact-id exact --contract deterministic\nbijux vex execute --artifact-id exact --vector [0,1,0] --top-k 1 --contract deterministic\nbijux vex artifact --artifact-id ann --contract non_deterministic\nbijux vex execute --artifact-id ann --vector [0,1,0] --top-k 1 --contract non_deterministic --randomness-profile seed=1\nbijux vex explain --artifact-id exact --result-id &lt;vector_id&gt;\nbijux vex compare --artifact-id exact --other-id ann\n</code></pre>"},{"location":"#execution-truth-table-canonical","title":"Execution truth table (canonical)","text":"Contract Support level Replayable Output stability Provenance / audit Notes deterministic stable yes (bit-identical) stable full chain + fingerprints frozen ABI; breaking changes require major bump non_deterministic stable_bounded no (envelope only) outcome-variable (bounded divergence) approximation + randomness metadata required experimental surface; may fail if ANN backend unavailable"},{"location":"#stability-guarantees","title":"Stability guarantees","text":"<ul> <li>Supported Python: 3.11\u20133.13 (CI + metadata aligned).</li> <li>Package version: dynamic from git tags via hatch-vcs.</li> <li>Public API version: v1.x (frozen; breaking changes require major bump).</li> <li>Execution ABI: see <code>docs/spec/execution_contracts.md</code> and tests; changes require a new ABI version.</li> <li>Determinism gates, ANN contracts, and provenance schema are enforced in conformance tests; regressions fail CI.</li> </ul>"},{"location":"#no-synonym-drift","title":"No synonym drift","text":"<p>We use one term per concept: replayable (deterministic, bit-identical), audited (non-deterministic with envelopes), stable (supported and frozen), outcome-variable (bounded divergence). Avoid \u201creproducible\u201d or \u201csupported\u201d as stand-ins.</p>"},{"location":"#public-surfaces","title":"Public surfaces","text":"<ul> <li>CLI (Typer): <code>create</code>, <code>ingest</code>, <code>materialize</code>, <code>execute</code>, <code>explain</code>, <code>replay</code>, <code>compare</code>, <code>list-artifacts</code>.</li> <li>API (FastAPI): versioned under <code>bijux_vex.api.v1</code> with frozen OpenAPI (<code>api/v1/openapi.v1.json</code>), endpoints mirror CLI verbs.</li> <li>Core types: <code>ExecutionContract</code>, <code>ExecutionRequest</code>, <code>ExecutionArtifact</code>, <code>ExecutionResources</code>, <code>ApproximationReport</code>, <code>RandomnessProfile</code>.</li> </ul>"},{"location":"#non-goals-checksum","title":"Non-goals checksum","text":"<p>\u274c Not a VDB or search service. \u274c Not an ML/embedding framework. \u274c Not a serving layer with SLAs. \u274c Not a \u201cbest-effort\u201d ANN wrapper\u2014contracts must be explicit.</p>"},{"location":"#why-strict","title":"Why strict","text":"<p>Aggressive invariants, terminal failures, and refusal to fallback exist to keep provenance honest and prevent silent divergence; permissive modes are intentionally rejected.</p>"},{"location":"#assumptions","title":"Assumptions","text":"<ul> <li>Trusted runtime and honest backend declaration.  </li> <li>Data is non-adversarial unless stated in tests.  </li> <li>Users read the \u201cStart here\u201d path before touching API/CLI.</li> </ul>"},{"location":"#when-contracts-are-violated","title":"When contracts are violated","text":"<ul> <li>Deterministic: execution refuses to run; replay fails closed.  </li> <li>Non-deterministic: fails fast if ANN unavailable or metadata missing; never silently falls back to deterministic.  </li> <li>Budget or capability breaches raise typed errors; no hidden retries or approximations.</li> </ul>"},{"location":"#contributing-release","title":"Contributing &amp; release","text":"<ul> <li>Keep invariants terminal; ND without metadata is forbidden.</li> <li>Run <code>make lint quality security test</code> before any PR.</li> <li>Release process: see <code>docs/maintainer/release_process.md</code>; tags drive package versions, SBOM, and wheels.</li> <li>Licensing: code under MIT; docs/config under CC0. See <code>docs/legal/licensing.md</code>.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog_1","title":"Changelog","text":"<p>All notable changes to this project are documented here. This file is generated via towncrier; do not edit by hand.</p>"},{"location":"changelog/#v010-first-public-release","title":"v0.1.0 (first public release)","text":"<ul> <li>First public, contract-complete release of bijux-vex.</li> <li>Deterministic execution with replayable artifacts and provenance.</li> <li>Non-deterministic execution via ANN with approximation reports and randomness audit.</li> <li>CLI and FastAPI v1 surfaces frozen; OpenAPI schema versioned.</li> <li>Provenance, determinism, and execution ABI enforced via conformance tests.</li> </ul>"},{"location":"api/","title":"API v1 overview","text":"<p>The API is versioned and contract-driven. This page is descriptive; the canonical contract is <code>api/v1/schema.yaml</code>, and the generated JSON is <code>api/v1/openapi.v1.json</code> (derived; do not edit).</p>"},{"location":"api/#guarantees","title":"Guarantees","text":"<ul> <li>Versioned under <code>/api/v1</code>; breaking changes require a new version.</li> <li>Deterministic and non-deterministic executions are explicit; no implicit defaults.</li> <li>Error model is typed and mapped to HTTP status codes (see <code>api/errors.md</code>).</li> </ul>"},{"location":"api/#stability-and-versioning","title":"Stability and versioning","text":"<ul> <li>API schema is frozen via <code>schema.yaml</code>; drift is blocked by <code>make api-freeze</code>.</li> <li>Package versioning is tag-driven (hatch-vcs), and API stability is documented separately from package version.</li> </ul>"},{"location":"api/#how-to-use","title":"How to use","text":"<ul> <li>Consult <code>api/v1/schema.yaml</code> to generate clients or validate requests/responses.</li> <li>Use the CLI verbs as a mirror: create \u2192 ingest \u2192 materialize \u2192 execute \u2192 explain \u2192 replay \u2192 compare.</li> <li>For non-deterministic executions, supply execution budgets and randomness profiles as required by the schema.</li> </ul>"},{"location":"api/#references","title":"References","text":"<ul> <li>Canonical schema (YAML): <code>api/v1/schema.yaml</code></li> <li>Generated JSON: <code>api/v1/openapi.v1.json</code></li> <li>Errors: <code>api/errors.md</code></li> </ul>"},{"location":"api/cli_exit_codes/","title":"CLI exit codes","text":"<p>The CLI is part of the public surface. Exit codes are intentional and stable:</p> <ul> <li><code>0</code>: success.</li> <li><code>2</code>: validation or invariant failure (misuse, contract violation).</li> <li><code>3</code>: backend capability or availability failure (e.g., ND without ANN).</li> <li><code>4</code>: budget exhaustion or policy refusal.</li> <li><code>1</code>: unexpected internal error (treated as a bug).</li> </ul> <p>There are no silent retries or fallbacks; failures are terminal and mapped to the nearest code above.</p>"},{"location":"api/errors/","title":"API Error Model (v1)","text":"<p>Errors are explicit, typed, and mapped to HTTP and retry semantics.</p> <ul> <li><code>ValidationError</code> \u2192 400, not retryable</li> <li><code>InvariantError</code> \u2192 422, terminal</li> <li><code>BackendCapabilityError</code> \u2192 422, fix configuration</li> <li><code>AuthzDeniedError</code> \u2192 403</li> <li><code>ConflictError</code> / <code>AtomicityViolationError</code> \u2192 409</li> <li><code>AnnIndexBuildError</code> / <code>AnnQueryError</code> \u2192 500</li> <li><code>AnnBudgetError</code> / <code>BudgetExceededError</code> \u2192 422, not retryable</li> <li><code>ReplayNotSupportedError</code> \u2192 422</li> <li>All errors carry invariant IDs where applicable.</li> </ul> <p>Clients should not rely on string matching; use status codes and error type names. Retries are only allowed when errors are explicitly marked retryable in the payload or classification tests.</p>"},{"location":"api/examples/","title":"OpenAPI v1 normative examples","text":"<p>These payloads are normative; changing them is a breaking API change.</p>"},{"location":"api/examples/#execute-deterministic","title":"Execute (deterministic)","text":"<pre><code>{\n  \"vector\": [0.0, 1.0],\n  \"top_k\": 3,\n  \"execution_contract\": \"deterministic\",\n  \"execution_intent\": \"exact_validation\"\n}\n</code></pre>"},{"location":"api/examples/#execute-non_deterministic-ann","title":"Execute (non_deterministic, ANN)","text":"<pre><code>{\n  \"vector\": [0.0, 1.0],\n  \"top_k\": 3,\n  \"execution_contract\": \"non_deterministic\",\n  \"execution_intent\": \"exploratory_search\",\n  \"execution_mode\": \"bounded\",\n  \"execution_budget\": { \"max_ann_probes\": 10, \"max_error\": 0.2 },\n  \"randomness_profile\": { \"seed\": 1, \"sources\": [\"ann_graph\"] }\n}\n</code></pre>"},{"location":"api/examples/#compare","title":"Compare","text":"<pre><code>{\n  \"artifact_id\": \"exact\",\n  \"other_artifact_id\": \"ann\"\n}\n</code></pre>"},{"location":"api/openapi/","title":"OpenAPI v1","text":"<ul> <li>Canonical contract: <code>api/v1/schema.yaml</code> (human-reviewed, versioned)</li> <li>Generated artifact: <code>api/v1/openapi.v1.json</code> (derived; do not edit manually)</li> </ul> <p>Use the schema to generate clients or validate requests/responses. Breaking changes require a new API version.</p> <ul> <li>Download schema.yaml</li> <li>Download openapi.v1.json</li> </ul>"},{"location":"design/contracts/","title":"bijux-vex v1 Contract Spec","text":"<p>bijux-vex is a contract-driven vector execution system with explicit determinism semantics. Every surface binds to a small set of contracts; anything outside these contracts is rejected.</p>"},{"location":"design/contracts/#canonicalization-ids","title":"Canonicalization + IDs","text":"<ul> <li>Canonical bytes and fingerprints are stable and versioned.</li> <li>Modules: <code>src/bijux_vex/core/canon.py</code>, <code>src/bijux_vex/core/ids.py</code>, <code>src/bijux_vex/core/types.py</code>.</li> </ul>"},{"location":"design/contracts/#tx-authz-audit","title":"Tx + authz + audit","text":"<ul> <li>All mutations run inside a <code>Tx</code>, with explicit authz checks and tamper-evident audit chaining.</li> <li>Modules: <code>src/bijux_vex/contracts/tx.py</code>, <code>src/bijux_vex/contracts/authz.py</code>, <code>src/bijux_vex/domain/provenance/audit.py</code>.</li> </ul>"},{"location":"design/contracts/#executionartifact","title":"ExecutionArtifact","text":"<ul> <li>Portable description of an execution artifact: fingerprints, metric, scoring version, <code>ExecutionContract</code>, and replayability.</li> <li>Modules: <code>src/bijux_vex/core/types.py</code> (<code>ExecutionArtifact</code>), <code>src/bijux_vex/core/ids.py</code>, <code>src/bijux_vex/core/invariants.py</code>.</li> </ul>"},{"location":"design/contracts/#executionrequest-determinism","title":"ExecutionRequest determinism","text":"<ul> <li>Identical execution requests over identical corpora yield identical ranked results under the deterministic contract.</li> <li>Modules: <code>src/bijux_vex/core/types.py</code>, <code>src/bijux_vex/domain/execution_requests/scoring.py</code>, <code>tests/conformance/execution_request_determinism.py</code>.</li> </ul>"},{"location":"design/contracts/#explainability-replay","title":"Explainability + replay","text":"<ul> <li>Results must be explainable doc\u2192chunk\u2192vector\u2192artifact\u2192score with provenance that carries <code>execution_contract</code>, <code>nondeterministic_sources</code>, and <code>lossy_dimensions</code>.</li> <li><code>ReplayOutcome</code> declares divergence; deterministic runs must match, non-deterministic runs must mark lossiness.</li> <li>Modules: <code>src/bijux_vex/domain/provenance/audit.py</code>, <code>src/bijux_vex/domain/provenance/lineage.py</code>, <code>src/bijux_vex/domain/provenance/replay.py</code>, <code>tests/conformance/test_execution_contracts.py</code>.</li> </ul>"},{"location":"design/contracts/#backend-isolation","title":"Backend isolation","text":"<ul> <li>Backend-specific knobs stay below <code>src/bijux_vex/infra/adapters/</code>.</li> <li>Forbidden leakage: backend table names, ANN parameters, backend-native IDs, or backend-specific consistency/authz semantics.</li> <li>Adapters translate contracts to backend knobs; the conformance suite must run unchanged across backends.</li> </ul>"},{"location":"design/determinism/","title":"Determinism Rules","text":"<p>These rules define the determinism gate. Identical inputs + configuration must yield byte-identical artifacts. They apply to the deterministic execution contract only; ANN mode is documented separately in <code>execution_contracts.md</code> and explicitly forfeits replayability.</p>"},{"location":"design/determinism/#canonical-json","title":"Canonical JSON","text":"<ul> <li>Serialize with sorted keys.</li> <li>Lists must be emitted in a stable order; upstream ordering must be deterministic before serialization.</li> <li>No implicit defaults: every serialized field is explicit and ordered.</li> <li>Encoding is UTF-8 without BOM; no trailing whitespace.</li> </ul>"},{"location":"design/determinism/#float-normalization","title":"Float Normalization","text":"<ul> <li>NaN and \u00b1Inf are forbidden; validation must reject them.</li> <li>Finite floats are normalized via canonical JSON string form produced by Python <code>repr</code> on <code>float</code> (deterministic across runs for finite values).</li> <li>No rounding/quantization beyond the source value; callers must pre-quantize if needed.</li> </ul>"},{"location":"design/determinism/#ranking-tie-breaks","title":"Ranking Tie-Breaks","text":"<ul> <li>Ranking order is <code>(score, vector_id, chunk_id, document_id)</code> ascending by score, then lexicographic by IDs.</li> <li>Scores that compare equal after normalization must still be ordered by these explicit keys.</li> <li>Backends must not introduce hidden randomness; any deterministic seed must be part of the query spec.</li> </ul>"},{"location":"design/determinism/#example-executable","title":"Example (executable)","text":"<p>from bijux_vex.core.identity.ids import fingerprint fp1 = fingerprint({\"doc\": 1}) fp2 = fingerprint({\"doc\": 1}) fp1 == fp2 True</p>"},{"location":"design/execution_contracts/","title":"Execution Contracts","text":"<p>bijux-vex supports two explicit execution contracts. There is no default: callers must choose the contract when materializing execution artifacts and when issuing execution requests.</p>"},{"location":"design/execution_contracts/#deterministic","title":"Deterministic","text":"<ul> <li>Exact execution; vector scores are stable and tie-broken deterministically.</li> <li>Replayable: execution requests can be re-run and compared byte-for-byte via fingerprints.</li> <li>Execution artifacts and provenance record <code>execution_contract=deterministic</code> and remain fully explainable.</li> </ul>"},{"location":"design/execution_contracts/#non-deterministic-ann","title":"Non-deterministic (ANN)","text":"<ul> <li>Uses declared approximate runners; results may differ across runs even with identical inputs.</li> <li>Replay is allowed but must declare divergence via <code>nondeterministic_sources</code>, <code>lossy_dimensions</code>, and replay details.</li> <li>Treated as an operational escape hatch, not the primary mode. Deterministic and non-deterministic contracts cannot mix on the same artifact ID.</li> </ul>"},{"location":"design/execution_contracts/#positioning","title":"Positioning","text":"<ul> <li>Deterministic mode is the first-class experience and the baseline for conformance.</li> <li>ANN is opt-in per execution artifact and must refuse deterministic contracts.</li> <li>Provenance is never silent: lossy paths must describe why an exact replay is impossible.</li> </ul>"},{"location":"design/glossary/","title":"Glossary","text":"<ul> <li>Document: Source text unit provided by users.</li> <li>Chunk: Deterministic slice of a document with stable ordinal.</li> <li>Vector: Numeric representation associated with a chunk and model.</li> <li>ExecutionArtifact: Portable description of an execution build and its provenance.</li> <li>ExecutionContract: Required determinism contract for every artifact and execution request.</li> <li>Backend: Adapter implementation of execution resources.</li> <li>Tx: Transaction boundary required for any mutation.</li> <li>Authz: Authorization hook invoked before mutations.</li> <li>AuditRecord: Tamper-evident record chaining mutation history.</li> <li>Determinism: Contract where replay MUST be bit-identical; hidden randomness forbidden.</li> <li>Non-determinism: Contract where randomness MUST be declared; replay checks envelopes, not equality.</li> <li>Replay: Re-running the same plan under the same contract; deterministic \u21d2 equality, ND \u21d2 bounded envelope. Replayable means re-execution is possible, not that results are cached.</li> <li>Stability: Deterministic surfaces are frozen; ND/ANN is stable at the contract level but outcomes vary within declared bounds.</li> <li>Reproducibility: Ability to obtain the same execution behavior under the same plan/contract/randomness; stronger than \u201csimilar results.\u201d</li> <li>Determinism vs reproducibility: determinism demands identical outputs; ND reproducibility means divergence stays within the recorded approximation envelope.</li> </ul>"},{"location":"design/non_goals/","title":"Non-goals (hard exclusions)","text":"<p>bijux-vex is a vector execution engine. The following are explicitly out of scope:</p> <ul> <li>Not a vector database or general-purpose datastore.</li> <li>Not a model runner or embedding factory.</li> <li>Not a retrieval framework or RAG orchestration layer.</li> <li>Not a streaming/online serving tier or SLA scheduler.</li> <li>Not an auto-tuner for ANN parameters.</li> <li>Not a distributed coordination or sharding system.</li> <li>Not a streaming/async result delivery mechanism; executions are bounded, audited batches only.</li> </ul> <p>Any change that drifts into these areas must be rejected unless the scope is explicitly revised.</p>"},{"location":"design/rejected_alternatives/","title":"Rejected design alternatives","text":"<p>These are intentionally rejected to prevent future regressions.</p> <ul> <li>VDB-style CRUD APIs: rejected; bijux-vex is an execution engine, not storage. Silent persistence semantics would dilute contracts.</li> <li>Implicit retries on invariants: rejected; invariants are terminal programmer/system faults. Retrying hides bugs and corrupts provenance.</li> <li>Silent ND fallback to deterministic: rejected; violates declared contracts. ND without ANN must fail explicitly.</li> <li>Hidden randomness: rejected; all randomness must be declared via <code>RandomnessProfile</code> and audited.</li> <li>Adaptive schema drift: rejected; OpenAPI/ABI changes require additive evolution or version bumps, never silent drift.</li> </ul>"},{"location":"design/scope/","title":"Scope","text":"<p>bijux-vex delivers contract-driven vector execution semantics (not a database). v1 focuses on:</p> <ul> <li>deterministic canonicalization and IDs</li> <li>transactional mutation with authz + audit</li> <li>backend-agnostic execution resources and conformance suite</li> <li>reference memory + SQLite adapters with explicit execution contracts</li> </ul> <p>Excluded (v1): streaming ingestion, distributed execution, on-device embedding inference, backend tuning controls above adapters.</p>"},{"location":"design/vdb_comparison/","title":"Why bijux-vex is not a vector DB (concrete comparison)","text":"<p>bijux-vex is an execution engine; vector DBs are storage/serving systems. Key differences:</p> <ul> <li>Contracts first: every execution declares determinism vs non-determinism; vector DBs often hide approximation trade-offs.</li> <li>Replay semantics: deterministic replay is enforced; ND replay is envelope-validated. Most vector DBs offer best-effort behavior without provenance.</li> <li>Provenance: executions emit lineage, randomness, and approximation metadata as a first-class artifact; vector DBs treat queries as transient.</li> <li>Capability honesty: backends must declare support for ND and determinism; vector DBs frequently downgrade silently.</li> <li>No CRUD semantics: bijux-vex does not expose database operations; ingestion/materialization are execution-scoped, not general storage APIs.</li> </ul> <p>Use bijux-vex when you need audited, contract-bound vector execution. Use a vector DB when you need a managed serving tier with CRUD and scale-out storage.</p>"},{"location":"design/why_vector_execution/","title":"Why vector execution \u2260 vector storage","text":"<p>bijux-vex is a vector execution engine. It treats every query as an explicit execution with a contract, an intent, and a surfaced randomness profile. Storing vectors is necessary but insufficient; the value is in how executions are planned, run, compared, and replayed.</p>"},{"location":"design/why_vector_execution/#why-determinism-matters","title":"Why determinism matters","text":"<ul> <li>Deterministic executions (DETERMINISTIC) must replay exactly. bijux-vex refuses to run them through approximate paths and fingerprints every execution.</li> <li>Non-deterministic executions (NON_DETERMINISTIC) declare their loss surface up front: randomness sources, replay bounds, and provenance flags.</li> </ul>"},{"location":"design/why_vector_execution/#why-approximation-must-be-explicit","title":"Why approximation must be explicit","text":"<ul> <li>ANN is only allowed when the execution intent justifies it (exploratory search, production retrieval with budgets).</li> <li>RandomnessSurface captures the sources of non-determinism so divergence is declared, not hidden.</li> </ul>"},{"location":"design/why_vector_execution/#why-existing-vdbs-conflate-concerns","title":"Why existing VDBs conflate concerns","text":"<ul> <li>Most vector databases merge storage and execution, hiding algorithm choice and randomness behind \u201cquery\u201d APIs.</li> <li>They rarely expose execution lineage, making replay and cross-backend comparison brittle.</li> </ul>"},{"location":"design/why_vector_execution/#how-bijux-vex-fits-the-ecosystem","title":"How bijux-vex fits the ecosystem","text":"<ul> <li>bijux-vex focuses on vector execution with explicit determinism semantics; reasoning and RAG concerns live elsewhere. Execution traces, contracts, and intents remain first-class here for vector workloads.</li> <li>VectorExecution is the unit of meaning here: it records the request, contract, backend, algorithm, parameters, and randomness surface. Artifacts reference executions by hash, keeping lineage auditable.</li> </ul> <p>Use bijux-vex when you need to compare exact vs approximate runs, measure divergence, and keep replayability honest. Don\u2019t use it as a generic datastore or a serving tier\u2014it\u2019s an execution lab, not a database.</p>"},{"location":"examples/audit_narrative/","title":"Audit narrative (truth trace)","text":"<p>Flow:</p> <pre><code>request (contract + intent + budget)\n  \u2192 session (state machine binds randomness + resources)\n  \u2192 plan (fingerprinted, capability-checked)\n  \u2192 execution (algorithm + contract + randomness applied)\n  \u2192 result (deterministic/ND + ApproximationReport + DeterminismReport)\n  \u2192 audit (ledger + chain hash)\n  \u2192 replay/compare (deterministic \u21d2 equality, ND \u21d2 envelope) or refusal\n</code></pre> <p>Key checkpoints: - Contract/intent validated up front; ND without ANN raises <code>NDExecutionUnavailableError</code>. - Plan immutability enforced before execution (fingerprint check). - Provenance persisted with approximation + randomness metadata. - Replay refuses without provenance; compare requires matching provenance lineage.</p>"},{"location":"examples/canonical/","title":"Canonical vector execution pipeline","text":"<p>This is the single example to understand bijux-vex:</p> <ol> <li>ingest a small corpus (document + vector)</li> <li>materialize an execution artifact (deterministic)</li> <li>execute deterministically</li> <li>execute non-deterministically with randomness declared</li> <li>compare the two executions</li> <li>explain a result</li> </ol> <p>Everything else in bijux-vex is this pipeline with different knobs.</p>"},{"location":"examples/contract_violation/","title":"Contract violation example","text":"<p>This shows a minimal invariant failure and the exact error raised.</p>"},{"location":"examples/contract_violation/#scenario","title":"Scenario","text":"<ul> <li>Artifact built for deterministic execution.</li> <li>Request attempts non-deterministic execution without ANN support.</li> </ul>"},{"location":"examples/contract_violation/#command","title":"Command","text":"<pre><code>bijux vex execute --artifact-id exact --vector [0,1,0] --top-k 1 --contract non_deterministic\n</code></pre>"},{"location":"examples/contract_violation/#expected-result","title":"Expected result","text":"<ul> <li>Execution is rejected with <code>NDExecutionUnavailableError</code>.</li> <li>Error message: <code>Non-deterministic execution requested without ANN support</code>.</li> <li>Provenance/audit records the failure; no execution occurs.</li> </ul>"},{"location":"examples/contract_violation/#why-it-is-forbidden","title":"Why it is forbidden","text":"<ul> <li>Non-deterministic execution requires an ANN backend to honor the contract.</li> <li>Silent fallback to deterministic would violate declared execution semantics.</li> <li>ND execution is stable_bounded at the contract level but still experimental in behavior; refusal without ANN keeps the contract honest.</li> <li>Error message is stable and public: <code>Non-deterministic execution requested without ANN support</code>.</li> </ul>"},{"location":"examples/nd_reproducibility/","title":"Non-deterministic reproducibility experiment","text":"<p>This walkthrough shows what changes and what stays bounded when running the same ND execution repeatedly.</p>"},{"location":"examples/nd_reproducibility/#setup","title":"Setup","text":"<pre><code>bijux vex create --name repro\nbijux vex ingest --name repro --documents \"hi\" --vectors \"[[0.0, 0.0]]\"\nbijux vex materialize --name repro --contract non_deterministic --budget-latency 5 --budget-memory 5 --budget-error 0.2\n</code></pre>"},{"location":"examples/nd_reproducibility/#run-the-same-nd-execution-3-times","title":"Run the same ND execution 3 times","text":"<pre><code>for i in 1 2 3; do\n  bijux vex execute --name repro --vector \"[0.0,0.0]\" --top-k 1 \\\n    --contract non_deterministic --mode bounded \\\n    --budget-latency 5 --budget-memory 5 --budget-error 0.2 \\\n    --randomness-seed $i\ndone\n</code></pre>"},{"location":"examples/nd_reproducibility/#what-you-should-see","title":"What you should see","text":"<ul> <li>Results may vary in rank/score order, but <code>ApproximationReport</code> records:</li> <li>algorithm, version, backend</li> <li><code>randomness_sources</code>, <code>random_seed</code></li> <li><code>recall_at_k</code>, <code>rank_displacement</code>, <code>distance_error</code></li> <li>Provenance shows the randomness envelope and ND contract.</li> </ul> <p>Sample truncated output (3 runs):</p> <pre><code>{\"approximation\":{\"algorithm\":\"hnswlib\",\"rank_displacement\":0.0,\"recall_at_k\":1.0,\"random_seed\":1},\"results\":[{\"rank\":1,\"score\":0.0,\"vector_id\":\"vec-0\"}]}\n{\"approximation\":{\"algorithm\":\"hnswlib\",\"rank_displacement\":0.0,\"recall_at_k\":1.0,\"random_seed\":2},\"results\":[{\"rank\":1,\"score\":0.0,\"vector_id\":\"vec-0\"}]}\n{\"approximation\":{\"algorithm\":\"hnswlib\",\"rank_displacement\":0.0,\"recall_at_k\":1.0,\"random_seed\":3},\"results\":[{\"rank\":1,\"score\":0.0,\"vector_id\":\"vec-0\"}]}\n</code></pre>"},{"location":"examples/nd_reproducibility/#replay-envelope","title":"Replay envelope","text":"<p>Replay of ND executions does not expect equality. It validates that observed divergence stays within the recorded approximation bounds; otherwise replay fails with a contract violation.</p>"},{"location":"examples/overview/","title":"Examples overview","text":"<p>Use these scenarios to learn the system quickly. Follow them in order.</p> <p>1) Exact execution: <code>spec/examples/exact_execution.md</code>    - Run a deterministic query, inspect replayable artifacts. 2) ANN execution: <code>spec/examples/ann_execution.md</code>    - Run a non-deterministic query with an ANN runner, see approximation reports. 3) Deterministic replay: <code>spec/examples/deterministic_replay.md</code>    - Prove deterministic outputs match across runs. 4) ND execution with audit: <code>spec/examples/nd_execution_with_audit.md</code>    - Inspect randomness, approximation metadata, and replay envelopes. 5) Forcing case: <code>spec/examples/forcing_case.md</code>    - Combined budget exhaustion + fallback + divergence audit. 6) Limitations and failure modes: <code>spec/examples/ugly_truth.md</code>    - Understand how and why executions can fail. 7) Contract violation: <code>examples/contract_violation.md</code>    - Intentional misuse: ND requested without ANN support returns <code>NDExecutionUnavailableError</code>.</p> <p>Tips: - Cross-check each example with the API schema (<code>api/v1/schema.yaml</code>) if using HTTP. - Keep the non-goals in mind: this is not a vector DB or RAG system.</p>"},{"location":"legal/licensing/","title":"Licensing","text":"<ul> <li>Code: MIT License (see <code>LICENSE</code> in the repository root).</li> <li>Documentation and configuration assets: CC0-1.0 unless otherwise noted.</li> </ul> <p>By contributing, you agree to license your contributions under the same terms. If you include third-party code or assets, ensure their licenses are compatible and documented.</p>"},{"location":"maintainer/compatibility_breaks/","title":"What WILL break compatibility","text":"<p>Changes that REQUIRE a major version bump: - Changing deterministic execution semantics or ABI. - Removing or renaming public API modules: <code>bijux_vex.core.types</code>, <code>bijux_vex.core.contracts.execution_contract</code>, <code>bijux_vex.core.runtime.vector_execution</code>, <code>bijux_vex.contracts.resources</code>, <code>bijux_vex.services.execution_engine</code>, <code>bijux_vex.api.v1</code>. - Changing public error types or their messages for deterministic paths. - Changing OpenAPI v1 schema in a non-additive way. - Altering provenance structure such that existing artifacts cannot be replayed/validated.</p> <p>Changes that do NOT require a major bump (but still need tests/docs): - Additive OpenAPI v1 fields with safe defaults. - New internal modules or refactors that do not touch public surfaces. - Performance improvements that preserve deterministic behavior and ND envelopes. - Additional examples or docs that do not alter contracts.</p>"},{"location":"maintainer/debt_log/","title":"Architectural debt log","text":"<ul> <li>Layer gap: Services vs orchestration remain split for public surface stability. Remove when CLI/tests can depend directly on <code>_orchestrator</code>.</li> <li>Policy flattening: Temporary removal of <code>core/policy</code>; revisit when compliance rules need isolation.</li> <li>Error-as-value: Only one path uses <code>ExecutionOutcome</code>; widen once callers migrate away from exceptions.</li> <li>Replay semantics: ND replay now re-executes and may diverge; formalize envelopes before widening backend set.</li> </ul>"},{"location":"maintainer/deletion_policy/","title":"Deletion policy","text":"<ul> <li>Prefer deletion over abstraction when:</li> <li>invariants can be enforced without an extra layer</li> <li>an extension seam is unused across releases</li> <li>a feature is undocumented or not backed by specs/tests</li> <li>Any new abstraction must list the invariant it enforces; otherwise delete or inline.</li> <li>Deprecations: mark in docs/spec/identity.md and remove in next minor unless ecosystem-bound.</li> <li>Freeze rule: dead code or unused flags are removed before tagging; no \u201cmaybe later\u201d retention.</li> </ul>"},{"location":"maintainer/design_diary/","title":"Design diary (traceability)","text":"<p>This diary records design pressures, reversals, and lessons learned. Update it only when something hurts.</p> <ul> <li>ANN integration: kept a single reference runner to avoid taxonomy sprawl; randomness surfaces must be explicit and audited.</li> <li>Replay semantics: deterministic is replayable; ND is envelope-validated only. Storing <code>replayable</code> was removed to prevent drift.</li> <li>Capability honesty: backends must declare <code>supports_ann</code>; dishonesty now fails fast with structured errors.</li> <li>Retention limits: ledgers enforce artifact/result caps to avoid slow operational leaks.</li> </ul> <p>When making changes, add a short bullet describing the pressure and the chosen trade-off.</p>"},{"location":"maintainer/do_not_optimize/","title":"Do not optimize (by design)","text":"<p>These are intentionally \u201cheavy\u201d and must stay that way: - Canon normalization and fingerprinting: preserve provenance integrity. - Invariant checks: fail fast; do not bypass or \u201cretry\u201d invariants. - Execution state machine: explicit transitions prevent ghost states. - Replay requiring provenance: no shortcuts; missing provenance must fail. - ND refusal without ANN: keeps contracts honest; no silent fallback.</p> <p>Optimizing away these checks is a correctness regression.</p>"},{"location":"maintainer/docs_freeze_checklist/","title":"Documentation freeze checklist","text":"<p>Use this before tagging any v0.1.x release. Documentation is a release artifact.</p> <ul> <li>[ ] <code>mkdocs build --strict</code> passes with zero warnings.</li> <li>[ ] All Markdown files are reachable from navigation (see <code>tests/unit/test_docs_invariants.py</code>).</li> <li>[ ] README links and badges validated (docs, spec, API, examples, license, start_here).</li> <li>[ ] <code>docs/user/start_here.md</code> present and linked from README and docs home.</li> <li>[ ] API contract: <code>api/v1/schema.yaml</code> committed; <code>make api-freeze</code> produces no drift.</li> <li>[ ] Docs are self-contained (no cross-repo references).</li> <li>[ ] Experimental surfaces (ND/ANN) labeled consistently across README, spec, and API.</li> <li>[ ] Changelog reflects current release and states \u201cfirst public release\u201d history squash.</li> <li>[ ] Release checklist items that touch docs are complete (<code>docs/maintainer/release_checklist.md</code>).</li> <li>[ ] Documentation debt log (<code>docs/maintainer/debt_log.md</code>) reviewed and none of the items block freeze.</li> <li>[ ] Root docs (README, docs/index.md, start_here) are frozen; any change after freeze requires compatibility justification in <code>docs/maintainer/compatibility_breaks.md</code>.</li> </ul>"},{"location":"maintainer/extension_points/","title":"Extension points (public seams)","text":"<p>Allowed: - New adapters implementing <code>contracts.resources.VectorSource</code>/<code>ExecutionLedger</code> respecting ExecutionContract capabilities. - New ANN runners subclassing <code>AnnExecutionRequestRunner</code> that declare randomness sources, bounds, and deterministic fallback policy. - New execution algorithms registered via <code>domain.execution_algorithms.base.register_algorithm</code> that respect contract compatibility.</p> <p>Forbidden: - Injecting execution logic into services or boundaries layers. - Extending public API without corresponding spec coverage and invariant IDs. - Mutating provenance or ledger entries post-commit.</p> <p>Warnings (will break determinism if abused): - Randomness sources not surfaced in <code>DeterminismReport</code>. - Adapters claiming deterministic support while using approximate paths. - Bypassing <code>ExecutionSession</code>/<code>ExecutionPlan</code> when executing.</p>"},{"location":"maintainer/extension_policy/","title":"Extension acceptance policy","text":"<p>Welcome: - New backends/adapters that honor contracts and invariants. - New comparison policies or audit/reporting extensions. - Additional examples, docs, or tooling that reinforce contracts.</p> <p>Not welcome: - Extensions that bypass contracts (silent fallback, hidden randomness). - New public entrypoints that duplicate existing verbs (<code>execute</code>, <code>replay</code>, <code>compare</code>, <code>explain</code>). - Mutations during replay or compare paths.</p> <p>Rules: - Public API modules are fixed; extend via documented seams (adapters, policies), not by adding new surfaces. - Any extension must document its invariants and add tests that enforce them.</p>"},{"location":"maintainer/freeze_criteria/","title":"Freeze criteria (v0.1.0)","text":"<p>Freeze is allowed only when all gates are satisfied: - Core decomposition in place (contracts/runtime/policies/types/identity) with no file &gt;300 LOC doing mixed responsibilities. - Services contain glue only; decision logic delegated to commands/domain. - Test tree mirrors src tree 1:1. - Adversarial execution scenarios pass (drift-within-bounds, corruption replay refusal, budget exhaustion). - Failure semantics and invariants documented and enforced by tests. - No TODO/FIXME in <code>src/bijux_vex/core</code>. - Docs: mental_model, failure_semantics, vdb_profile present and linked in doc map. - All gates: <code>make test lint quality security</code> green. - Exclusions honored: <code>pgvector_backend</code> remains excluded (see <code>core/v1_exclusions.py</code>). - Deterministic execution surface and ABI are frozen; breaking deterministic changes require a major version bump. - Non-deterministic/ANN execution is experimental and may change; users must treat ND behavior as unstable. - Posture: bijux-vex is contract-complete and open to empirical refinement; feature changes must be framed as contract extensions and approved through freeze governance.</p> <p>Kill-switch: if any criterion fails, release tagging is blocked and freeze is revoked.</p>"},{"location":"maintainer/if_i_disappear/","title":"If I disappear","text":"<ul> <li>Releases: run <code>make lint quality security test docs api</code> then <code>make release</code>; tags drive versions (hatch-vcs).</li> <li>Must never change: deterministic execution semantics/ABI, public API modules, error taxonomy for deterministic paths.</li> <li>Say \u201cno\u201d to PRs that: bypass contracts, add DB-like semantics, or weaken invariants.</li> <li>Docs/tests are gates: mkdocs strict, api-freeze, conformance suites must stay green.</li> <li>Contact/review: treat ND/ANN changes as experimental; require contract/test updates.</li> </ul>"},{"location":"maintainer/maintenance_mode_criteria/","title":"Maintenance-mode criteria (future)","text":"<p>Do not declare maintenance-only until: - at least one stable public release cycle (v0.1.x \u2192 v0.2.x) with migration experience. - documented external adopters and integrations. - no pending contract changes or experimental ND features. - governance decision recorded in design_diary and freeze_criteria.</p> <p>Until then: bijux-vex is contract-complete and open to empirical refinement.</p>"},{"location":"maintainer/makefile_contract/","title":"Makefile contract","text":"<p>The Makefile targets are part of the public tooling surface. Changes require justification in <code>docs/maintainer/compatibility_breaks.md</code>.</p> <p>Stable targets (treated as contracts): - <code>install</code>, <code>bootstrap</code> - <code>fmt</code>, <code>lint</code>, <code>test</code>, <code>quality</code>, <code>security</code>, <code>docs</code>, <code>api</code>, <code>hygiene</code>, <code>sbom</code> - <code>all</code>, <code>clean</code>, <code>clean-soft</code> - <code>release</code></p> <p>Reserved/UX-parity targets: - <code>build</code>: intentionally fails with guidance to use <code>make release</code>. - <code>citation</code>: intentionally fails until citation metadata is published.</p> <p>Any new target added for CI or user workflows must be documented here before release.</p>"},{"location":"maintainer/release_checklist/","title":"Release checklist (v0.1.x)","text":"<ul> <li>[ ] Working tree clean; no untracked artifacts.</li> <li>[ ] <code>make lint quality security test</code> passes with zero warnings.</li> <li>[ ] <code>make docs</code> (mkdocs build --strict) passes; no navigation warnings.</li> <li>[ ] <code>docs/maintainer/docs_freeze_checklist.md</code> reviewed and satisfied.</li> <li>[ ] <code>api/v1/schema.yaml</code> committed; <code>make api-freeze</code> passes (no drift).</li> <li>[ ] OpenAPI validation tests green; schema reachable in docs.</li> <li>[ ] README badges and docs links verified.</li> <li>[ ] CHANGELOG updated via towncrier; v0.1.0 section accurate.</li> <li>[ ] Release artifacts built (<code>make release</code>): wheel/sdist, SBOM, refreshed OpenAPI.</li> <li>[ ] Tags signed: <code>git tag -s v0.1.x</code>.</li> <li>[ ] CI workflows (ci.yml, release.yml) green on tag.</li> </ul>"},{"location":"maintainer/release_dry_run/","title":"Release dry-run checklist","text":"<p>Use this before tagging to avoid publishing broken artifacts.</p> <ul> <li>Clean tree; <code>make lint quality security api test</code> green.</li> <li><code>make api</code> regenerates schema with no drift.</li> <li>Build wheel locally: <code>python -m build</code> (or <code>make release</code> if enabled).</li> <li>Install wheel in a fresh venv, run <code>bijux vex --help</code>, and execute a deterministic flow end-to-end.</li> <li><code>mkdocs build --strict</code> succeeds (docs reachable, no warnings).</li> <li>SBOM generated (<code>make sbom</code>) with zero unignored vulns.</li> <li>Confirm README badges and links resolve.</li> </ul>"},{"location":"maintainer/release_process/","title":"Release process (bijux-vex v0.1.x)","text":""},{"location":"maintainer/release_process/#preconditions","title":"Preconditions","text":"<ul> <li>Working tree clean; <code>git status</code> empty.</li> <li>All gates green: <code>make lint quality security test</code>.</li> <li>Public API surface and OpenAPI freeze tests passing.</li> <li>Execution ABI fingerprint unchanged or intentionally bumped with doc updates.</li> </ul>"},{"location":"maintainer/release_process/#versioning-and-tagging","title":"Versioning and tagging","text":"<ul> <li>Version derives from git tags via <code>hatch-vcs</code>; do not edit <code>pyproject.toml</code> for version bumps.</li> <li>Tag format: <code>v0.1.0</code>, <code>v0.1.0-rc1</code>, etc.</li> <li>Dirty worktree produces a <code>.dirty</code> local version; do not publish in that state.</li> </ul>"},{"location":"maintainer/release_process/#release-steps","title":"Release steps","text":"<p>1) <code>make lint quality security test</code> 2) <code>make docs</code> (mkdocs build --strict) 3) <code>make api-freeze</code> (ensures schema.yaml \u2192 openapi.v1.json drift-free) 4) <code>make release</code> (builds wheel+sdist, SBOM, refreshes OpenAPI) 5) Update CHANGELOG via towncrier if needed. 6) Confirm <code>docs/maintainer/release_checklist.md</code> is complete. 7) Create signed tag <code>git tag -s v0.1.0 -m \"v0.1.0\"</code> 8) Push tag: <code>git push origin v0.1.0</code></p>"},{"location":"maintainer/release_process/#github-automation-expectations","title":"GitHub automation expectations","text":"<ul> <li>CI workflow must run tests, lint, quality, security on PRs and tags.</li> <li>Release workflow should build wheel/sdist, attach SBOM, and upload artifacts to the GitHub release page.</li> <li>Tag protection: only signed, CI-green tags are published.</li> </ul>"},{"location":"maintainer/release_process/#post-release","title":"Post-release","text":"<ul> <li>Update docs/README if behavior changed.</li> <li>If ABI or public surface shifts, bump PUBLIC API or ABI versions and document rationale.</li> </ul>"},{"location":"maintainer/security_model/","title":"Security &amp; abuse model","text":"<p>In scope: - Replay poisoning: mitigated via provenance hashes and immutable artifacts. - Artifact spoofing: mitigated via fingerprint checks and audit chain. - Capability refusal: ND without ANN results in <code>NDExecutionUnavailableError</code>. - Authz denial: mutations blocked via <code>Authz</code> contracts.</p> <p>Out of scope: - Multi-tenant isolation guarantees. - Network-level ACLs beyond Authz hooks. - Side-channel attacks or timing analysis.</p> <p>Operator guidance: - Treat provenance ledger as tamper-evident; rotate or archive per retention policy. - Run divergence detection to catch backend drift. - Do not bypass invariants via retry wrappers. - Vulnerability posture: <code>py==1.11.0</code> triggers PYSEC-2022-42969 with no upstream fix yet. SBOM generation ignores this ID explicitly until a patched release is available; upgrade once released.</p>"},{"location":"maintainer/testing_policy/","title":"Testing policy (frozen)","text":"<ul> <li>tox runs the full test matrix across supported Python versions.</li> <li>Lint, quality, security, typing gates run once on the oldest supported Python (3.11) to control CI time/cost; this is intentional.</li> <li>pytype is skipped (Python version churn + maintenance cost); do not re-enable without explicit approval. If installed, it is advisory only.</li> <li>Contributors must not \u201coptimize\u201d gates to run on all versions; matrix belongs in tox only.</li> </ul>"},{"location":"maintainer/why_this_is_hard/","title":"Why this is hard","text":"<ul> <li>Vector execution is harder than storage: algorithms, randomness, and approximation choices happen at runtime, not at ingest.</li> <li>ANN breaks na\u00efve determinism: traversal order, pruning, and sampling introduce entropy that must be declared and bounded.</li> <li>Replay is non-trivial: deterministic replay demands bit-stability; ND replay demands statistical envelopes and provenance strong enough to prove consistency.</li> <li>Backend drift is silent: without comparison and divergence detection, approximate systems rot unnoticed.</li> <li>Budgets are hard constraints: latency/memory/probe limits must halt execution, not merely warn.</li> </ul>"},{"location":"maintainer/rationale/anti_goals/","title":"bijux-vex anti-goals","text":"<ul> <li>Not a vector database or key-value store.</li> <li>Not an embedding or model inference framework.</li> <li>Not a RAG orchestration system.</li> <li>Not a generic serving layer or SLA manager.</li> <li>Not a benchmark suite; comparisons exist to validate contracts, not to market performance.</li> </ul> <p>Every new feature must demonstrate how it strengthens vector execution contracts or auditability. If it drifts toward these anti-goals, it should be rejected.</p>"},{"location":"maintainer/rationale/philosophy/","title":"bijux-vex philosophy","text":"<ul> <li>bijux-vex is a vector execution engine, not a database.</li> <li>Contracts (deterministic vs non-deterministic) are first-class and enforced.</li> <li>Execution artifacts are replayable evidence, not storage indexes.</li> <li>Approximation is explicit, auditable, and comparable against exact runs.</li> <li>Backends are interchangeable execution substrates that must declare capabilities and refuse incompatible contracts.</li> </ul>"},{"location":"overview/concepts/","title":"Conceptual overview","text":"<p>This page is descriptive, not normative. It explains bijux-vex in plain language without APIs or enums.</p>"},{"location":"overview/concepts/#what-bijux-vex-is","title":"What bijux-vex is","text":"<ul> <li>A vector execution engine: it runs vector similarity computations under explicit contracts.</li> <li>Contracts come in two flavors:</li> <li>Deterministic: exact algorithms, replayable outputs, bit-stable provenance.</li> <li>Non-deterministic: ANN/approximate algorithms, bounded divergence, declared randomness.</li> <li>Every run is tied to an execution plan, provenance, and artifacts that record how results were produced.</li> </ul>"},{"location":"overview/concepts/#vector-execution-vs-vector-db","title":"Vector execution vs. vector DB","text":"<ul> <li>Vector DBs focus on storage and serving; execution is implicit and often approximate by default.</li> <li>bijux-vex focuses on execution semantics: what was run, under which guarantees, and how to replay or compare results.</li> <li>Artifacts, plans, and provenance are first-class; storage backends are just sources and ledgers.</li> </ul>"},{"location":"overview/concepts/#core-objects-conceptual","title":"Core objects (conceptual)","text":"<ul> <li>Execution plan: the declared algorithm, contract, and parameters.</li> <li>Execution artifact: the outputs plus provenance and signatures.</li> <li>Provenance: the audit trail that explains how the artifact was produced.</li> <li>Randomness profile: where nondeterminism enters and how it is bounded.</li> </ul>"},{"location":"overview/concepts/#how-determinism-works-here","title":"How determinism works here","text":"<ul> <li>Deterministic runs use exact search and must replay identically.</li> <li>Non-deterministic runs must emit approximation reports and randomness metadata; replay checks envelopes, not equality.</li> </ul>"},{"location":"overview/concepts/#how-to-approach-the-docs","title":"How to approach the docs","text":"<ul> <li>If you want rules: go to <code>spec/system_contract.md</code> and <code>spec/execution_contracts.md</code>.</li> <li>If you want rationale: see <code>design/why_vector_execution.md</code> and <code>design/contracts.md</code>.</li> <li>If you want to run something: start with <code>examples/overview.md</code>.</li> </ul>"},{"location":"spec/architecture_diagram/","title":"Architecture diagram (single source)","text":"<p>Textual diagram:</p> <p><code>CLI/API \u2192 Orchestrator (glue only) \u2192 ExecutionSession (state machine) \u2192 ExecutionPlan (immutable) \u2192 Algorithm (exact/approx mode) \u2192 VectorSource + ANN runner \u2192 ExecutionResult + Provenance \u2192 Ledger</code></p> <p>Contracts/invariants hit: - Contract alignment (INV-010) at session start - Randomness/budget required for ND (INV-020) in planning - Plan immutability/fingerprint in ExecutionPlan - Determinism enforcement pre-algorithm selection - Provenance requirement on replay (INV-040) - Ledger integrity on persist/replay</p>"},{"location":"spec/doc_to_code_map/","title":"Doc to code map","text":"<ul> <li>docs/spec/read_this_first.md \u2192 src/bijux_vex/core</li> <li>docs/spec/execution_contracts.md \u2192 src/bijux_vex/core/contracts, src/bijux_vex/domain/execution_requests</li> <li>docs/spec/failure_semantics.md \u2192 src/bijux_vex/core/errors, src/bijux_vex/core/failures.py</li> <li>docs/spec/execution_lifecycle.md \u2192 src/bijux_vex/core/runtime, src/bijux_vex/domain/execution_requests</li> <li>docs/spec/execution_artifacts.md \u2192 src/bijux_vex/domain/execution_artifacts</li> <li>docs/spec/examples \u2192 tests/e2e</li> <li>docs/spec/system_contract.md \u2192 src/bijux_vex</li> <li>docs/spec/invariant_ids.md \u2192 src/bijux_vex/core/errors/error_types.py</li> <li>docs/maintainer/why_this_is_hard.md \u2192 docs/maintainer</li> <li>docs/spec/mental_model.md \u2192 src/bijux_vex/core</li> <li>docs/spec/vdb_profile.md \u2192 src/bijux_vex</li> <li>docs/maintainer/freeze_criteria.md \u2192 docs/maintainer</li> <li>docs/spec/identity.md \u2192 src/bijux_vex</li> <li>docs/user/not_a_vdb.md \u2192 docs/user</li> <li>docs/maintainer/extension_points.md \u2192 src/bijux_vex</li> </ul>"},{"location":"spec/execution_artifacts/","title":"Execution artifacts","text":"<p>An execution artifact records what ran and how: - links to corpus + vector fingerprints - execution contract and plan fingerprint - randomness audit (sources, budget) - approximation + determinism reports - execution signature tying all of the above</p> <p>Portability guarantees: - Artifacts are versioned; compatibility is enforced by the execution ABI. - Replay does not require live vector sources; artifacts plus plan are sufficient. - Backends must refuse execution if they cannot meet the artifact\u2019s contract/metric.</p> <p>Mutation rules: - Artifacts are immutable once committed. - Ledger retention may prune historical results but preserves chain hash integrity.</p> <p>Docs \u2192 code - <code>src/bijux_vex/core/execution_result.py</code> - <code>src/bijux_vex/core/abi/__init__.py</code> - <code>src/bijux_vex/domain/execution_artifacts/</code></p>"},{"location":"spec/execution_contracts/","title":"Execution contracts","text":""},{"location":"spec/execution_contracts/#deterministic-execution","title":"Deterministic execution","text":"<ul> <li>MUST guarantee bit-stable results.</li> <li>MUST NOT include hidden randomness or approximate paths.</li> <li>Replay MUST match exactly; any divergence is an invariant failure.</li> <li>Backends MUST declare <code>deterministic_query=True</code> and MUST refuse if they cannot meet it.</li> </ul>"},{"location":"spec/execution_contracts/#non-deterministic-execution","title":"Non-deterministic execution","text":"<ul> <li>Fully supported in v0.1.x; refusal must be contractual and explicit.</li> <li>REQUIRES:</li> <li><code>RandomnessProfile</code> (seed, sources, boundedness, budget)</li> <li><code>DeterminismReport</code> persisted with every result</li> <li><code>ApproximationReport</code> (recall, rank displacement, distance error, algorithm, backend, randomness sources, fallback flag)</li> <li>Replay MUST compare within declared bounds (distribution-consistent), not equality.</li> <li>See <code>docs/spec/non_deterministic_execution.md</code> for the full semantics.</li> </ul>"},{"location":"spec/execution_contracts/#allowed-sources-of-nondeterminism","title":"Allowed sources of nondeterminism","text":"<ul> <li>Graph traversal order.</li> <li>Sampling/beam heuristics.</li> <li>Parallelism-induced ordering changes. All MUST be named in the plan via <code>RandomnessSource</code>.</li> </ul>"},{"location":"spec/execution_contracts/#comparison-semantics","title":"Comparison semantics","text":"<ul> <li>Exact vs approximate comparisons MUST measure recall@k, rank instability, overlap ratio.</li> <li>Policies MAY gate approximate runs: minimum recall, maximum instability.</li> </ul>"},{"location":"spec/execution_contracts/#versioning-rationale","title":"Versioning rationale","text":"<ul> <li>ABI versioning exists to keep deterministic replay stable across refactors.</li> <li>Canon versioning exists to keep fingerprints and hashing rules stable for provenance chains.</li> <li>Schema versioning (API/OpenAPI) exists to keep external integrations honest; breaking changes require a new major API version.</li> </ul>"},{"location":"spec/execution_contracts/#doc-code-map","title":"Doc \u2192 code map","text":"<ul> <li>Contracts: <code>src/bijux_vex/core/contracts/__init__.py</code></li> <li>Randomness profile: <code>src/bijux_vex/core/vector_execution.py</code></li> <li>Reports: <code>src/bijux_vex/core/execution_result.py</code></li> <li>Enforcement: <code>src/bijux_vex/domain/execution_requests/execute.py</code>, <code>plan.py</code></li> </ul>"},{"location":"spec/execution_intent_matrix/","title":"Execution intent contract matrix","text":"intent allowed contracts allowed modes EXACT_VALIDATION deterministic strict REPRODUCIBLE_RESEARCH deterministic, non_deterministic strict (DET), bounded/ exploratory (ND) EXPLORATORY_SEARCH non_deterministic bounded, exploratory PRODUCTION_RETRIEVAL deterministic strict <p>Rules: - Intent is always explicit and coerced to <code>ExecutionIntent</code> at boundary ingress. - Non-deterministic intents require an execution budget and randomness profile. - Deterministic intents must use strict mode; ND intents must not use strict mode.</p>"},{"location":"spec/execution_lifecycle/","title":"Execution lifecycle (canonical)","text":"<p>Flow (text diagram): <code>ExecutionSession.start</code> \u2192 <code>ExecutionPlan.build</code> \u2192 <code>execute_request</code> \u2192 <code>postprocess</code> \u2192 <code>ledger.persist</code> \u2192 <code>replay|compare</code></p> <p>Where invariants fire: - Session start: contract alignment, capability checks (INV-010, capability invariants). - Planning: randomness required for ND (INV-020), ABI compatibility. - Execute: budget enforcement, ANN refusal for deterministic. - Postprocess: determinism/approximation reports attached. - Ledger persist: artifact/signature immutability. - Replay: provenance required (INV-040); deterministic equality vs ND envelope.</p> <p>Determinism enforcement: - Contract split before algorithm selection. - ND requires randomness profile + budget; deterministic forbids ANN paths. - Replay checks <code>results_fingerprint</code> (deterministic) or divergence envelope (ND).</p> <p>Artifacts and provenance: - ExecutionResult stores plan, cost, approximation, determinism report, fingerprints. - ExecutionArtifact ties corpus/vector fingerprints to execution signature. - Ledger retention may compact but must preserve chain hashes.</p> <p>Docs \u2192 code - <code>src/bijux_vex/core/runtime/execution_plan.py</code> - <code>src/bijux_vex/core/runtime/execution_session.py</code> - <code>src/bijux_vex/domain/execution_requests/plan.py</code> - <code>src/bijux_vex/domain/execution_requests/execute.py</code> - <code>src/bijux_vex/domain/provenance/replay.py</code></p>"},{"location":"spec/failure_semantics/","title":"Failure semantics","text":"<ul> <li>InvariantError: terminal, never retryable; indicates contract or state violation.</li> <li>BudgetExceededError: execution stops, may return partial results; classified as retryable only if budgets are adjusted.</li> <li>BackendDivergenceError: indicates drift between backends; requires operator action, not blind retry.</li> <li>ValidationError / ConflictError / NotFoundError: client or request issues; retries without change are meaningless.</li> <li>AtomicityViolationError: transactional misuse; must be fixed in code/tests.</li> <li>NDExecutionUnavailableError: non-deterministic execution requested without ANN support; allowed failure mode, caller must select a deterministic contract or provide ANN backend.</li> </ul> <p>Classification lives in <code>FailureKind</code> and <code>FAILURE_ACTIONS</code>: - retryable: transient backend or IO failures (not invariants). - terminal: invariants, ABI mismatches, capability refusals. - alert/escalate: backend divergence, provenance corruption.</p>"},{"location":"spec/failure_semantics/#error-semantics-table","title":"Error semantics table","text":"Error type Retryable User-visible Provenance impact Deterministic outcome <code>InvariantError</code> No Yes Recorded as terminal failure Execution aborted <code>ValidationError</code> No Yes Recorded N/A <code>BudgetExceededError</code> No (partial) Yes Partial results stored; status PARTIAL Deterministic: mismatch; ND: allowed with divergence recorded <code>BackendDivergenceError</code> No Yes Stored with divergence detail Deterministic: failure; ND: allowed with bounds <code>ReplayNotSupportedError</code> No Yes No new provenance N/A <code>AuthzDeniedError</code> No Yes No execution recorded N/A <code>NotFoundError</code> No Yes No execution recorded N/A <code>NDExecutionUnavailableError</code> No Yes Recorded with capability refusal N/A Stable public errors <code>ValidationError</code>, <code>InvariantError</code>, <code>ConflictError</code>, <code>NotFoundError</code>, <code>AuthzDeniedError</code>, <code>BackendDivergenceError</code>, <code>BackendCapabilityError</code>, <code>ReplayNotSupportedError</code>, <code>BudgetExceededError</code>, <code>AnnIndexBuildError</code>, <code>AnnQueryError</code>, <code>AnnBudgetError</code>, <code>NDExecutionUnavailableError</code> <p>Docs \u2192 code - <code>src/bijux_vex/core/errors/error_types.py</code> - <code>src/bijux_vex/core/failures.py</code> - <code>src/bijux_vex/domain/provenance/replay.py</code></p>"},{"location":"spec/identity/","title":"bijux-vex identity (freeze-bound)","text":"<ul> <li>bijux-vex is a vector execution engine with explicit contracts for determinism, nondeterminism, and replay.</li> <li>bijux-vex is not a vector database, embedding service, or retrieval framework. It records execution consequences; it does not offer serving SLAs.</li> <li>bijux-vex solves the problem of running and comparing deterministic vs approximate vector executions with auditable provenance. Reasoning execution is intentionally out of scope; bijux-vex is the vector execution engine.</li> <li>Use bijux-vex when you need: replayable vector experiments, explicit nondeterministic bounds, cross-backend drift detection, and compliance gates on approximation.</li> <li>Do not use bijux-vex when you need: low-latency serving, multi-tenant storage, model hosting, or generic RAG pipelines. Use a vector DB + discipline instead.</li> <li>Contract: every execution requires an execution contract, intent, budget, and session; provenance is mandatory for replay. If these feel heavy, bijux-vex is the wrong tool.</li> <li>Thesis: bijux-vex makes deterministic and approximate vector execution comparable, auditable, and replayable as contracts. Existing vector stores cannot enforce or explain determinism/approximation gaps at this level.</li> </ul>"},{"location":"spec/invariant_ids/","title":"Invariant IDs","text":"<p>Every invariant failure MUST emit an ID. Defaults use <code>INV-000</code> but should be replaced with specific IDs over time.</p> <ul> <li>INV-000: unspecified invariant violation (temporary default)</li> <li>INV-010: execution contract mismatch</li> <li>INV-011: backend capability refusal</li> <li>INV-020: missing randomness for ND execution</li> <li>INV-021: budget exhaustion triggered</li> <li>INV-030: plan fingerprint mismatch</li> <li>INV-040: deterministic replay divergence</li> </ul> <p>Each ID MUST appear in exception text and MUST be covered by at least one test.</p>"},{"location":"spec/invariants_overview/","title":"Invariants overview (one page)","text":"<pre><code>Request\n  | (contract + intent + budget validated)\n  v\nSession\n  | (state machine; randomness + resources bound)\n  v\nPlan (fingerprinted)\n  | (immutability enforced; capabilities checked)\n  v\nExecution\n  | (algorithm + contract + randomness applied)\n  v\nResult + Provenance\n  | (approximation + determinism reports; audit chain)\n  v\nReplay/Compare\n  | (deterministic \u21d2 equality; ND \u21d2 envelope)\n</code></pre> <p>Invariants fire at every arrow: - Contract/intent/budget required. - Session transitions guarded. - Plan fingerprint verified before execution. - ND requires randomness profile and approximation report; deterministic forbids randomness. - Provenance is mandatory; replay refuses without it.</p>"},{"location":"spec/irreducible_core/","title":"Irreducible core (must survive any refactor)","text":"<p>Non-negotiable invariants: 1) Contract alignment (INV-010): artifact and request execution_contract must match; enforced in planning and replay. 2) Determinism declaration (INV-020): ND execution requires explicit randomness + budget; deterministic path forbids ANN. 3) Provenance requirement (INV-040): replay only legal with stored execution result and matching contract/ABI. 4) Plan immutability: ExecutionPlan fingerprint ties algorithm+contract+k+randomness; mutation invalidates execution. 5) Ledger integrity: artifacts/results persisted with signatures; deletion/compaction must preserve chain hashes.</p> <p>Minimum modules to enforce: - <code>core/runtime/execution_plan.py</code> (plan fingerprint, randomness labels) - <code>core/runtime/execution_session.py</code> (state machine, contract alignment) - <code>core/contracts/execution_contract.py</code> + <code>core/contracts/determinism.py</code> - <code>domain/execution_requests/plan.py</code> (capability + contract checks) - <code>domain/provenance/replay.py</code> (provenance gate) - <code>core/invariants.py</code> + <code>core/contracts/invariants.py</code> (guardrails)</p> <p>Everything else is supportive. If removed, these must remain intact for vex to stay itself.</p>"},{"location":"spec/mental_model/","title":"Mental model (non-negotiable)","text":"<p>This file is the single-page spine for bijux-vex v0.1.0. Read this before any other doc.</p>"},{"location":"spec/mental_model/#what-an-execution-is","title":"What an execution is","text":"<ul> <li>A <code>VectorExecution</code> = <code>(ExecutionRequest + ExecutionPlan + ExecutionContract + VectorSource + RandomnessProfile + ExecutionSession)</code>.</li> <li>An execution always produces two artifacts: an immutable <code>ExecutionResult</code> (with cost + determinism report) and an <code>ExecutionArtifact</code> lineage entry in the ledger.</li> <li>Execution identity is <code>ExecutionSignature(request, plan, contract, randomness, parameters, vectors)</code> and is hash-stable.</li> </ul>"},{"location":"spec/mental_model/#what-is-guaranteed","title":"What is guaranteed","text":"<ul> <li>If <code>ExecutionContract == DETERMINISTIC</code>, replay under the same signature MUST produce bit-identical results and matching <code>results_fingerprint</code>.</li> <li>If <code>ExecutionContract == NON_DETERMINISTIC</code>, replay MUST stay within declared <code>reproducibility_bounds</code> and emit a <code>DeterminismReport</code> describing randomness sources and bounds.</li> <li>Provenance is mandatory: replay is only legal when a stored <code>ExecutionResult</code> exists for the artifact.</li> <li>Budgets are enforced pre- and mid-plan; overruns result in <code>PARTIAL</code> status with <code>BudgetExceededError</code> provenance.</li> </ul>"},{"location":"spec/mental_model/#what-is-not-guaranteed","title":"What is not guaranteed","text":"<ul> <li>No persistence semantics beyond the execution ledger; this is not a vector DB.</li> <li>No implicit fallbacks: ANN runners MUST declare bounds; deterministic fallbacks are explicit.</li> <li>No silent retries: <code>InvariantError</code> and ABI violations are terminal.</li> <li>No execution without declared contract, intent, and session randomness policy.</li> </ul>"},{"location":"spec/mental_model/#replay-legality","title":"Replay legality","text":"<ul> <li>Legal replay requires: matching contract, stored <code>ExecutionResult</code>, and compatible ABI fingerprint.</li> <li>Deterministic replay: must produce identical <code>results_fingerprint</code>; mismatch is a failure.</li> <li>Non-deterministic replay: may diverge, but divergence MUST be recorded in <code>ReplayOutcome.details</code> and <code>DeterminismReport</code>.</li> <li>Replay is illegal if provenance is missing, contract mismatches, ABI fingerprint changed, or ledger is compacted past the required chain.</li> </ul>"},{"location":"spec/non_deterministic_execution/","title":"Non-deterministic execution (ND) semantics","text":"<p>ND execution is first-class and fully supported in v0.1.x. It is not a best-effort mode.</p> <ul> <li>Inputs and parameters must be deterministic (explicit seeds, declared randomness sources).</li> <li>Allowed divergence: ranking/score differences within declared approximation bounds; provenance must record randomness sources.</li> <li>Replay semantics: distribution-consistent. Replays MUST emit divergence envelopes, not equality, and MUST fail if randomness metadata is missing.</li> <li>Backends MUST declare whether they support ND; refusal is contractual, not an invariant failure.</li> <li>ND execution MAY legally fail with <code>NDExecutionUnavailableError</code> if no ANN backend is available; callers must provide ANN support or choose deterministic contracts.</li> <li>Every ND result MUST include:</li> <li><code>ApproximationReport</code> (recall, displacement, distance error, algorithm, backend, randomness_sources, fallback flag)</li> <li><code>DeterminismReport</code> with reproducibility bounds and randomness used.</li> </ul> <p>Code mapping: see <code>src/bijux_vex/core/contracts/execution_contract.py</code>, <code>src/bijux_vex/domain/execution_requests/postprocess.py</code>, <code>src/bijux_vex/domain/provenance/replay.py</code>, <code>tests/conformance/test_execution_contracts.py</code>.</p>"},{"location":"spec/read_this_first/","title":"bijux-vex \u2014 read this first","text":"<p>bijux-vex is a vector execution engine. It MUST run vector computations under explicit execution contracts, record the consequences, and make determinism vs. non-determinism auditable.</p>"},{"location":"spec/read_this_first/#what-vector-execution-means","title":"What vector execution means","text":"<ul> <li>Inputs are execution requests (text or vectors) routed through explicit plans.</li> <li>Backends are execution substrates, not storage layers.</li> <li>Artifacts are replayable records of how execution happened, not generic indexes.</li> </ul>"},{"location":"spec/read_this_first/#deterministic-vs-non-deterministic-contracts","title":"Deterministic vs non-deterministic contracts","text":"<ul> <li>Deterministic: bit-stable, replay MUST match exactly, no hidden randomness MAY exist.</li> <li>Non-deterministic: randomness MUST be declared, bounded, and audited; replay MUST check distributional consistency within declared bounds.</li> </ul>"},{"location":"spec/read_this_first/#why-ann-is-treated-as-execution-not-indexing","title":"Why ANN is treated as execution (not indexing)","text":"<ul> <li>ANN choices (graph walks, sampling, pruning) MUST be treated as execution-time decisions.</li> <li>Backends MUST refuse deterministic contracts when they cannot honor exactness.</li> <li>Approximation metadata (MUST include randomness sources and reproducibility bounds) is part of the execution artifact.</li> </ul>"},{"location":"spec/read_this_first/#replay-as-a-first-class-invariant","title":"Replay as a first-class invariant","text":"<ul> <li>Replay MUST mean \u201cre-run the same execution plan under the same contract.\u201d</li> <li>Deterministic replay \u21d2 equality; non-deterministic replay \u21d2 declared envelope.</li> <li>Provenance chains MUST include contract, randomness profile, and artifact signature.</li> </ul>"},{"location":"spec/read_this_first/#typing-philosophy","title":"Typing philosophy","text":"<ul> <li>Runtime contracts and invariants are primary; static typing is advisory.</li> <li>Type checkers MUST NOT be treated as soundness gates. Invariants, provenance, and conformance tests enforce correctness.</li> <li><code>ExecutionIntent</code> is represented canonically as intent strings (<code>exact_validation</code>, <code>reproducible_research</code>, <code>exploratory_search</code>, <code>production_retrieval</code>); the enum is a convenience veneer only.</li> </ul> <p>All other spec documents link back here as the canonical mental model.</p>"},{"location":"spec/refusals/","title":"What bijux-vex refuses to be","text":"<ul> <li>Not a vector database: no storage SLAs, no CRUD API beyond execution ingestion.</li> <li>Not a retrieval framework: no RAG orchestration, no ranking pipelines beyond execution plans.</li> <li>Not an embedding service: no model hosting or embedding generation.</li> <li>Not a serving layer: no latency/availability guarantees, budgets are experimental not production SLAs.</li> <li>Not a benchmarking suite: comparisons exist for contract enforcement, not leaderboard results.</li> <li>Not a reasoning engine: vector execution only.</li> </ul> <p>Intentionally missing abstractions: - No schema migration helpers for embeddings - No plug-and-play ANN plugin registry beyond declared runners - No automatic fallback unless declared by the runner/plan - No implicit retries on invariant/ABI violations</p>"},{"location":"spec/system_contract/","title":"System contract","text":"<p>bijux-vex is a vector execution engine. The following requirements are normative:</p> <ul> <li>The system MUST treat vector execution as the core unit; storage is supporting only.</li> <li>Deterministic executions MUST be bit-stable and MUST NOT contain hidden randomness.</li> <li>Non-deterministic executions MUST declare randomness sources, budgets, and reproducibility bounds; replay MUST verify within those bounds.</li> <li>Replay MUST mean re-running the same plan under the same contract; deterministic replay MUST match exactly, ND replay MUST stay within declared envelopes.</li> <li>Backends MUST refuse contracts they cannot honor.</li> <li>Absence of an ANN backend is a valid state; ND requests MAY fail with a contractual capability error (<code>NDExecutionUnavailableError</code>).</li> <li>bijux-vex MUST NOT position itself as a vector DB, embedding system, RAG stack, or serving layer.</li> <li>Public API modules (stable): <code>bijux_vex.core.types</code>, <code>bijux_vex.core.contracts.execution_contract</code>, <code>bijux_vex.core.runtime.vector_execution</code>, <code>bijux_vex.contracts.resources</code>, <code>bijux_vex.services.execution_engine</code>, <code>bijux_vex.api.v1</code>. Everything else is internal.</li> </ul> <p>Any code path or API that violates these statements is a defect.</p>"},{"location":"spec/vdb_profile/","title":"VEX stance on vector DB semantics","text":"<p>bijux-vex is not a vector database. It provides execution contracts, not storage guarantees. No <code>ExecutionProfile.VDB</code> exists for v0.1.0; any persistence semantics are limited to the execution ledger.</p> <p>Implications: - No CRUD API for vectors beyond fixture ingestion. - No serving/read/write SLAs. - Any adapter exposing database-like APIs must document why it exists and must not claim DB parity.</p>"},{"location":"spec/vocabulary/","title":"Vocabulary (authoritative)","text":"<ul> <li>Execution: interpreting an <code>ExecutionPlan</code> under an <code>ExecutionContract</code> against a <code>VectorSource</code>, producing an <code>ExecutionResult</code> + provenance.</li> <li>ExecutionPlan: immutable plan describing algorithm, contract, k, scoring, randomness sources, bounds; fingerprinted.</li> <li>ExecutionSession: lifecycle holder (state machine) tying plan + artifact + randomness + budget.</li> <li>Artifact: <code>ExecutionArtifact</code> linking corpus/vector fingerprints to execution signature; persisted in ledger.</li> <li>Provenance: ledger records (artifacts, results, audit chain) required for replay and comparison.</li> <li>Determinism: contract dimension; deterministic \u21d2 bit-identical replay; non_deterministic \u21d2 bounded divergence with <code>DeterminismReport</code>.</li> <li>Replay: re-running an execution with the same contract/ABI; deterministic checks equality, ND checks envelope. Replayable does not mean cached; it means re-execution is possible under the same contract.</li> <li>Comparison: structured diff between executions (overlap, recall delta, rank instability), exact vs approximate.</li> <li>Execution fidelity: mode expressing how close results adhere to exact semantics (deterministic exact vs ND approximate).</li> <li>Stability: deterministic surfaces are frozen; ND/ANN is stable_bounded (contract is stable, outcomes vary within declared envelopes).</li> <li>Reproducibility: ability to recreate execution behavior under the same contract/plan/randomness (deterministic \u21d2 equality, ND \u21d2 bounded envelope).</li> </ul>"},{"location":"spec/examples/ann_execution/","title":"ANN execution example","text":"<pre><code>bijux vex execute --contract non_deterministic --intent exploratory_search --vector \"[0.3,0.4]\" --budget.max_ann_probes 10\n</code></pre> <p>Expected: - ANN algorithm selected, randomness sources recorded - ApproximationReport persisted with recall/rank displacement - DeterminismReport present with reproducibility bounds</p> <p>Failure example: - Missing budget or randomness profile \u21d2 invariant failure before execution.</p>"},{"location":"spec/examples/deterministic_replay/","title":"Deterministic replay example","text":"<pre><code>bijux vex replay --artifact art-1 --contract deterministic\n</code></pre> <p>Expected: - Replay uses stored plan + artifact; no live vector source mutation. - Results match original execution exactly; mismatch raises InvariantError.</p> <p>Failure example: - Altered plan fingerprint \u21d2 replay refused.</p>"},{"location":"spec/examples/exact_execution/","title":"Exact execution example","text":"<pre><code>bijux vex create\nbijux vex ingest --text \"hello\"\nbijux vex materialize --metric l2\nbijux vex execute --contract deterministic --vector \"[0.1,0.2]\"\n</code></pre> <p>Expected: - deterministic plan, no randomness sources - execution artifact with no approximation report - replay returns identical results</p> <p>Failure example: - If backend lacks deterministic support, command fails with InvariantError.</p>"},{"location":"spec/examples/forcing_case/","title":"Forcing scenario: ND ANN with budget exhaustion and replay divergence","text":"<p>Steps (MUST): - Execute a NON_DETERMINISTIC ANN request with a strict budget (<code>max_vectors=0</code>, low latency). - Allow partial execution; status MUST be <code>PARTIAL</code>. - Fallback deterministic path MUST be used when ANN cannot proceed under budget. - Replay MUST re-run the plan and detect divergence against the baseline fingerprint.</p> <p>Invariants (IDs): - INV-020: Randomness required for ND execution. - INV-021: Budget exhaustion recorded, status PARTIAL. - INV-010: Contract alignment enforced. - INV-030: Plan fingerprint must not mutate between execution and replay.</p> <p>Expected behavior: - First run yields partial results and signature. - Replay with the baseline fingerprint produces a different results fingerprint and details indicating nondeterministic divergence. - Fallback path is exercised during replay to make divergence observable.</p>"},{"location":"spec/examples/nd_execution_with_audit/","title":"Non-deterministic execution with audit","text":"<pre><code>bijux vex execute --contract non_deterministic --vector \"[0.5,0.6]\" --budget.max_latency_ms 50 --budget.max_ann_probes 20\n</code></pre> <p>Expected: - RandomnessProfile captured (seed, sources, bounded flag, budget). - DeterminismReport includes randomness sources and reproducibility bounds. - ApproximationReport shows recall and displacement; status may be PARTIAL if budgets trigger.</p> <p>Failure example: - Missing randomness profile or budget triggers invariant failure; execution does not start.</p>"},{"location":"spec/examples/ugly_truth/","title":"Limitations and failure modes (descriptive)","text":"<p>Scenario: ND ANN execution with budget exhaustion, approximation, provenance, and replay mismatch.</p> <p>Steps (CLI narrative): 1. <code>bijux vex materialize --contract non_deterministic</code> 2. <code>bijux vex execute --vector ... --contract non_deterministic --budget max-ann-probes=1</code> 3. Execution returns PARTIAL with <code>BudgetExceededError</code> provenance and <code>DeterminismReport</code>. 4. Ledger stores <code>ExecutionResult</code> + artifact signature. 5. <code>bijux vex replay --contract non_deterministic</code> \u2192 mismatch allowed but recorded; <code>ReplayOutcome.details</code> carries divergence and randomness sources. 6. <code>bijux vex compare --exact artifact-A --approx artifact-B</code> \u2192 overlap/recall deltas highlight approximation loss.</p> <p>What it proves: - Budgets abort mid-plan, not post-hoc. - ND replay is legal but must declare divergence. - Provenance is required; replay without ledger state fails fast. - Approximation is auditable, not silent.</p>"},{"location":"spec/failure_narratives/budget_exhaustion/","title":"Failure narrative: budget exhaustion","text":"<ul> <li>Invariant: INV-021 (budget exhaustion must be explicit and halt progress).</li> <li>Trigger: ExecutionBudget limit (vectors/latency/probes) exceeded mid-plan.</li> <li>Response:</li> <li>Status becomes PARTIAL.</li> <li>BudgetExceededError (value) recorded with dimension.</li> <li>Replay still allowed; divergence expected for ND.</li> <li>Evidence:</li> <li>ExecutionResult.status == PARTIAL</li> <li>Failure reason includes <code>budget_exhausted_&lt;dimension&gt;</code></li> <li>Scenario: docs/spec/examples/forcing_case.md; tests/scenarios/test_forcing_case.py</li> </ul>"},{"location":"user/external_misuse/","title":"External misuse to avoid","text":"<ul> <li>Treating bijux-vex as a vector DB: there is no CRUD, indexing API, or serving tier; executions are contract-bound.</li> <li>Expecting ANN replay: ND executions provide approximation envelopes and audit but do not promise ANN result equality.</li> <li>Assuming implicit defaults: intents, contracts, and modes are mandatory; unknown strings are rejected.</li> <li>Using ND without budgets: bounded/exploratory modes require explicit budgets and randomness profiles.</li> </ul> <p>Use bijux-vex when you need audited execution comparisons, not managed vector storage.</p>"},{"location":"user/misuse/","title":"bijux-vex misuse patterns (real-world)","text":"<p>This page lists ways people are likely to misuse bijux-vex and the exact failure surfaces they will hit.</p> <ul> <li>Treating bijux-vex as a \u201cvector database\u201d: requests that expect CRUD or implicit persistence will fail with <code>InvariantError</code> or <code>BackendCapabilityError</code>; refer to <code>docs/user/not_a_vdb.md</code>.</li> <li>Requesting non-deterministic execution without ANN support: fails with <code>NDExecutionUnavailableError</code> (HTTP 503 / CLI non-zero) and an audit entry explaining missing <code>supports_ann</code>.</li> <li>Supplying string intents or modes: boundary coercion now rejects unknown values with <code>InvariantError</code>.</li> <li>Mixing deterministic replay with ND artifacts: replay refuses with <code>ReplayNotSupportedError</code> and provenance notes the contract mismatch.</li> <li>Ignoring budgets: deterministic runs reject pre-execution if budgets are impossible; ND runs emit <code>BudgetExceededError</code> with provenance.</li> </ul> <p>Always consult the contract docs before extending usage beyond the supported execution model.</p>"},{"location":"user/not_a_vdb/","title":"bijux-vex is not a vector DB","text":"<ul> <li>No storage contract: the execution ledger is provenance, not a database.</li> <li>No serving guarantees: latency/availability are not SLAs; budgets are for experiments.</li> <li>No CRUD API beyond fixtures and ingestion for execution.</li> <li>Determinism and nondeterminism are execution contracts, not storage modes.</li> <li>If you need multi-tenant vector storage, pick a vector DB and use bijux-vex for audited execution only.</li> <li>ANN replay is not promised: ND executions record envelopes and audit; replay validates envelopes, not ANN equality.</li> </ul>"},{"location":"user/start_here/","title":"Start here \u2014 bijux-vex onboarding","text":""},{"location":"user/start_here/#what-problem-does-bijux-vex-solve","title":"What problem does bijux-vex solve?","text":"<p>Vector execution often hides determinism assumptions. bijux-vex makes execution contracts explicit, auditable, and replayable so you can compare deterministic (exact) and non-deterministic (ANN) runs side by side.</p>"},{"location":"user/start_here/#when-should-you-use-it","title":"When should you use it?","text":"<ul> <li>You need reproducible deterministic vector execution with provenance you can replay.</li> <li>You want bounded, auditable non-deterministic execution (ANN) with explicit approximation and randomness metadata.</li> <li>You care about comparing exact vs approximate results across backends and artifacts.</li> </ul>"},{"location":"user/start_here/#deterministic-vs-non-deterministic-high-level","title":"Deterministic vs non-deterministic (high level)","text":"<ul> <li>Deterministic: exact search, bit-stable, replay required. No hidden randomness.</li> <li>Non-deterministic (ANN, experimental): approximate path only, bounded divergence, emits <code>ApproximationReport</code> + <code>RandomnessProfile</code>, replay is envelope-based.</li> </ul>"},{"location":"user/start_here/#what-to-read-next","title":"What to read next","text":"<p>1) Concepts: overview/concepts.md \u2014 mental model of execution vs storage. 2) Contracts: spec/system_contract.md and spec/execution_contracts.md. 3) Examples: examples/overview.md \u2014 deterministic and ANN flows. 4) API: api/index.md and the canonical schema api/v1/schema.yaml. 5) Not a vector DB: user/not_a_vdb.md.</p>"}]}