{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"bijux-vex \u2014 vector execution engine with explicit determinism","text":"<p>bijux-vex executes vector workloads under contracts. Deterministic runs are replayable; non-deterministic runs are bounded, audited, and comparable. Nothing is implicit: no silent defaults, retries, or randomness.</p>"},{"location":"#what-bijux-vex-is","title":"What bijux-vex is","text":"<p>Vector execution engine with explicit determinism contracts. Deterministic paths are bit-stable and replayable; non-deterministic paths (ANN) are supported but experimental and always emit approximation + randomness provenance.</p>"},{"location":"#what-bijux-vex-is-not","title":"What bijux-vex is not","text":"<ul> <li>Not a vector DB or storage layer.</li> <li>Not an embedding or RAG framework.</li> <li>Not a serving platform with SLAs.</li> </ul>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Start here (single onboarding path): user/start_here.md</li> <li>Docs home: https://bijux.github.io/bijux-vex/</li> <li>Concepts: overview/concepts.md</li> <li>API: api/index.md and <code>api/v1/schema.yaml</code> (canonical contract)</li> <li>Examples: examples/overview.md</li> <li>Changelog: changelog.md</li> <li>Not a vector DB: user/not_a_vdb.md</li> </ul>"},{"location":"#reading-order-guaranteed","title":"Reading order (guaranteed)","text":"<p>1) Start with user/start_here.md for the problem, fit, and next steps. 2) Then overview/concepts.md for execution vs storage and determinism vs non-determinism. 3) Then spec/system_contract.md and spec/execution_contracts.md for the normative rules. 4) Run examples/overview.md for deterministic and ANN flows. 5) Consult api/index.md and <code>api/v1/schema.yaml</code> when integrating. Everything else is reference or maintainer material.</p>"},{"location":"#start-here","title":"Start here","text":"<p>Read <code>docs/user/start_here.md</code>. It explains the problem, when to use bijux-vex, deterministic vs non-deterministic execution, and where to go next.</p>"},{"location":"#minimal-example-cli-10-lines","title":"Minimal example (CLI, 10 lines)","text":"<pre><code>bijux vex ingest --doc \"hello\" --vector \"[0,1,0]\"\nbijux vex materialize --execution-contract deterministic\nbijux vex execute --artifact-id art-1 --vector \"[0,1,0]\" --top-k 1 \\\n  --execution-contract deterministic --execution-intent exact_validation --execution-mode strict\nbijux vex replay --request-text \"hello\"\nbijux vex materialize --execution-contract non_deterministic\nbijux vex execute --artifact-id art-1 --vector \"[0,1,0]\" --top-k 1 \\\n  --execution-contract non_deterministic --execution-intent exploratory_search --execution-mode bounded \\\n  --randomness-seed 1 --randomness-sources reference_ann_hnsw --randomness-bounded \\\n  --max-latency-ms 10 --max-memory-mb 10 --max-error 0.5\nbijux vex compare --vector \"[0,1,0]\" --execution-intent exact_validation\n</code></pre>"},{"location":"#execution-truth-table-canonical","title":"Execution truth table (canonical)","text":"Contract Support level Replayable Output stability Provenance / audit Notes deterministic stable yes (bit-identical) stable full chain + fingerprints frozen ABI; breaking changes require major bump non_deterministic stable_bounded no (envelope only) outcome-variable (bounded divergence) approximation + randomness metadata required experimental surface; may fail if ANN backend unavailable"},{"location":"#stability-guarantees","title":"Stability guarantees","text":"<ul> <li>Supported Python: 3.11\u20133.13 (CI + metadata aligned).</li> <li>Package version: dynamic from git tags via hatch-vcs.</li> <li>Public API version: v1.x (frozen; breaking changes require major bump).</li> <li>Execution ABI: see <code>docs/spec/execution_contracts.md</code> and tests; changes require a new ABI version.</li> <li>Determinism gates, ANN contracts, and provenance schema are enforced in conformance tests; regressions fail CI.</li> </ul>"},{"location":"#no-synonym-drift","title":"No synonym drift","text":"<p>We use one term per concept: replayable (deterministic, bit-identical), audited (non-deterministic with envelopes), stable (supported and frozen), outcome-variable (bounded divergence). Avoid \u201creproducible\u201d or \u201csupported\u201d as stand-ins.</p>"},{"location":"#public-surfaces","title":"Public surfaces","text":"<ul> <li>CLI (Typer): <code>create</code>, <code>ingest</code>, <code>materialize</code>, <code>execute</code>, <code>explain</code>, <code>replay</code>, <code>compare</code>, <code>list-artifacts</code>, <code>vdb</code>.</li> <li>API (FastAPI): versioned under <code>bijux_vex.api.v1</code> with frozen OpenAPI (<code>api/v1/openapi.v1.json</code>), endpoints mirror CLI verbs.</li> <li>Core types: <code>ExecutionContract</code>, <code>ExecutionRequest</code>, <code>ExecutionArtifact</code>, <code>ExecutionResources</code>, <code>ApproximationReport</code>, <code>RandomnessProfile</code>.</li> </ul>"},{"location":"#non-goals-checksum","title":"Non-goals checksum","text":"<p>\u274c Not a VDB or search service. \u274c Not an ML framework; embeddings are optional and explicit. \u274c Not a serving layer with SLAs. \u274c Not a \u201cbest-effort\u201d ANN wrapper\u2014contracts must be explicit.</p>"},{"location":"#why-strict","title":"Why strict","text":"<p>Aggressive invariants, terminal failures, and refusal to fallback exist to keep provenance honest and prevent silent divergence; permissive modes are intentionally rejected.</p>"},{"location":"#assumptions","title":"Assumptions","text":"<ul> <li>Trusted runtime and honest backend declaration.  </li> <li>Data is non-adversarial unless stated in tests.  </li> <li>Users read the \u201cStart here\u201d path before touching API/CLI.</li> </ul>"},{"location":"#when-contracts-are-violated","title":"When contracts are violated","text":"<ul> <li>Deterministic: execution refuses to run; replay fails closed.  </li> <li>Non-deterministic: fails fast if ANN unavailable or metadata missing; never silently falls back to deterministic.  </li> <li>Budget or capability breaches raise typed errors; no hidden retries or approximations.</li> </ul>"},{"location":"#contributing-release","title":"Contributing &amp; release","text":"<ul> <li>Keep invariants terminal; ND without metadata is forbidden.</li> <li>Run <code>make lint quality security test</code> before any PR.</li> <li>Release process: see <code>docs/maintainer/release_process.md</code>; tags drive package versions, SBOM, and wheels.</li> <li>Licensing: code under MIT; docs/config under CC0. See <code>docs/legal/licensing.md</code>.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog_1","title":"Changelog","text":"<p>All notable changes to Bijux Vex are documented here. This project adheres to Semantic Versioning and the Keep a Changelog format.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>(add new entries via Towncrier fragments in <code>changelog.d/</code>)</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>(add here)</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>(add here)</li> </ul>"},{"location":"changelog/#020-2026-02-03","title":"0.2.0 \u2013 2026-02-03","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Explicit vector store adapters (memory/sqlite, FAISS, Qdrant) with capability reporting and status commands.</li> <li>Non\u2011Deterministic (ND) execution model with budgets, quality metrics, witness options, and provenance audit fields.</li> <li>Embedding provider interface, cache controls, and embedding provenance metadata.</li> <li>Determinism fingerprints, replay gates, and conformance tests for stability.</li> <li>Benchmarks, dataset generator, and baseline regression checks.</li> <li>Human\u2011first documentation, contracts, and operational guides (trust model, safety, failure modes).</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>CLI and API now require explicit vector store selection for persistence/ANN routes.</li> <li>Refusal semantics are standardized and surfaced consistently across CLI/API/provenance.</li> <li>Docs and onboarding flow rewritten for clarity, with explicit anti\u2011goals and guarantees.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Deterministic ordering rules and replay checks hardened across backends.</li> <li>Redaction rules tightened to prevent credential leakage in logs and provenance.</li> </ul>"},{"location":"changelog/#010-first-public-release","title":"0.1.0 \u2013 first public release","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>First public, contract\u2011complete release of bijux\u2011vex.</li> <li>Deterministic execution with replayable artifacts and provenance.</li> <li>Non\u2011deterministic execution via ANN with approximation reports and randomness audit.</li> <li>CLI and FastAPI v1 surfaces frozen; OpenAPI schema versioned.</li> <li>Provenance, determinism, and execution ABI enforced via conformance tests.</li> </ul>"},{"location":"api/","title":"API v1 overview","text":"<p>The API is versioned and contract-driven. This page is descriptive; the canonical contract is <code>api/v1/schema.yaml</code>, and the generated JSON is <code>api/v1/openapi.v1.json</code> (derived; do not edit).</p>"},{"location":"api/#guarantees","title":"Guarantees","text":"<ul> <li>Versioned under <code>/api/v1</code>; breaking changes require a new version.</li> <li>Deterministic and non-deterministic executions are explicit; no implicit defaults.</li> <li>Error model is typed and mapped to HTTP status codes (see <code>api/errors.md</code>).</li> </ul>"},{"location":"api/#stability-and-versioning","title":"Stability and versioning","text":"<ul> <li>API schema is frozen via <code>schema.yaml</code>; drift is blocked by <code>make api-freeze</code>.</li> <li>Package versioning is tag-driven (hatch-vcs), and API stability is documented separately from package version.</li> </ul>"},{"location":"api/#how-to-use","title":"How to use","text":"<ul> <li>Consult <code>api/v1/schema.yaml</code> to generate clients or validate requests/responses.</li> <li>CLI mirror: ingest \u2192 materialize \u2192 execute \u2192 explain \u2192 replay \u2192 compare.</li> <li>API endpoints: <code>/ingest</code> \u2192 <code>/artifact</code> \u2192 <code>/execute</code> \u2192 <code>/explain</code> \u2192 <code>/replay</code> (no <code>/compare</code> endpoint in v1).</li> <li>Optional routing fields: <code>vector_store</code>, <code>vector_store_uri</code> (ingest/execute/artifact) and <code>embed_model</code> (ingest).</li> <li>For non-deterministic executions, supply execution budgets and randomness profiles as required by the schema.</li> </ul>"},{"location":"api/#references","title":"References","text":"<ul> <li>Canonical schema (YAML): <code>api/v1/schema.yaml</code></li> <li>Generated JSON: <code>api/v1/openapi.v1.json</code></li> <li>Errors: <code>api/errors.md</code></li> </ul>"},{"location":"api/cli_exit_codes/","title":"CLI exit codes","text":"<p>The CLI is part of the public surface. Exit codes are intentional and stable:</p> <ul> <li><code>0</code>: success.</li> <li><code>2</code>: validation or invariant failure (misuse, contract violation).</li> <li><code>3</code>: backend capability or availability failure (e.g., ND without ANN).</li> <li><code>4</code>: budget exhaustion or policy refusal.</li> <li><code>1</code>: unexpected internal error (treated as a bug).</li> </ul> <p>There are no silent retries or fallbacks; failures are terminal and mapped to the nearest code above.</p>"},{"location":"api/errors/","title":"API Error Model (v1)","text":"<p>Errors are explicit, typed, and mapped to HTTP and retry semantics.</p> <ul> <li><code>ValidationError</code> \u2192 400, not retryable</li> <li><code>InvariantError</code> \u2192 422, terminal</li> <li><code>BackendCapabilityError</code> \u2192 422, fix configuration</li> <li><code>AuthzDeniedError</code> \u2192 403</li> <li><code>ConflictError</code> / <code>AtomicityViolationError</code> \u2192 409</li> <li><code>AnnIndexBuildError</code> / <code>AnnQueryError</code> \u2192 500</li> <li><code>AnnBudgetError</code> / <code>BudgetExceededError</code> \u2192 422, not retryable</li> <li><code>ReplayNotSupportedError</code> \u2192 422</li> <li>All errors carry invariant IDs where applicable.</li> </ul> <p>Clients should not rely on string matching; use status codes and error type names. Retries are only allowed when errors are explicitly marked retryable in the payload or classification tests.</p>"},{"location":"api/examples/","title":"OpenAPI v1 normative examples","text":"<p>These payloads are normative; changing them is a breaking API change.</p>"},{"location":"api/examples/#execute-deterministic","title":"Execute (deterministic)","text":"<pre><code>{\n  \"vector\": [0.0, 1.0],\n  \"top_k\": 3,\n  \"execution_contract\": \"deterministic\",\n  \"execution_intent\": \"exact_validation\"\n}\n</code></pre>"},{"location":"api/examples/#execute-non_deterministic-ann-experimental","title":"Execute (non_deterministic, ANN, experimental)","text":"<pre><code>{\n  \"vector\": [0.0, 1.0],\n  \"top_k\": 3,\n  \"execution_contract\": \"non_deterministic\",\n  \"execution_intent\": \"exploratory_search\",\n  \"execution_mode\": \"bounded\",\n  \"execution_budget\": { \"max_latency_ms\": 10, \"max_memory_mb\": 10, \"max_error\": 0.2 },\n  \"randomness_profile\": { \"seed\": 1, \"sources\": [\"reference_ann_hnsw\"], \"bounded\": true }\n}\n</code></pre>"},{"location":"api/openapi/","title":"OpenAPI v1","text":"<ul> <li>Canonical contract: <code>api/v1/schema.yaml</code> (human-reviewed, versioned)</li> <li>Generated artifact: <code>api/v1/openapi.v1.json</code> (derived; do not edit manually)</li> </ul> <p>Use the schema to generate clients or validate requests/responses. Breaking changes require a new API version.</p> <ul> <li>Download schema.yaml</li> <li>Download openapi.v1.json</li> </ul>"},{"location":"architecture/v0.2_narrative/","title":"v0.2 Architecture Narrative","text":"<p>This document captures the current architecture intent for Bijux Vex v0.2 so future work stays consistent.</p>"},{"location":"architecture/v0.2_narrative/#deterministic-path","title":"Deterministic Path","text":"<ul> <li>Input vectors or documents are ingested into a vector store.</li> <li>Exact execution uses deterministic algorithms and refuses any approximation.</li> <li>Provenance records the execution plan, determinism fingerprint, and results.</li> </ul>"},{"location":"architecture/v0.2_narrative/#nd-non-deterministic-path","title":"ND (Non-Deterministic) Path","text":"<ul> <li>ND uses an explicit execution model that plans, executes, verifies, and postprocesses.</li> <li>Runner selection and parameter resolution are explicit and recorded.</li> <li>Quality metrics are mandatory; if they cannot be measured, a reason is recorded.</li> <li>Reproducibility bounds are included with every ND result.</li> </ul>"},{"location":"architecture/v0.2_narrative/#storage-path","title":"Storage Path","text":"<ul> <li>Vector stores are pluggable and explicitly chosen by the caller.</li> <li>Vector store metadata is normalized and persisted alongside provenance.</li> <li>Backend capabilities are surfaced through capabilities and audit commands.</li> </ul>"},{"location":"architecture/v0.2_narrative/#provenance-model","title":"Provenance Model","text":"<ul> <li>Every execution emits a provenance artifact (execution result + metadata).</li> <li>ND provenance includes decision trace, quality metrics, and refusal metadata.</li> <li>Replay uses explicit contracts and refuses when mismatched.</li> </ul>"},{"location":"architecture/v0.2_narrative/#trust-boundaries","title":"Trust Boundaries","text":"<ul> <li>Deterministic execution is stable by contract.</li> <li>ND execution is bounded and labeled with quality and reproducibility signals.</li> <li>Storage backends must declare capabilities; unsupported operations are refused.</li> </ul>"},{"location":"contracts/backward_compatibility/","title":"Backward Compatibility Contract (v0.1.x \u2192 v0.2.x)","text":"<p>This document defines what will not change for v0.1.x users as bijux-vex moves through v0.2.x. If it is not listed here, it is not guaranteed.</p>"},{"location":"contracts/backward_compatibility/#cli-commands-guaranteed-unchanged","title":"CLI commands guaranteed unchanged","text":"<p>The following CLI commands (names + core semantics) are frozen from v0.1.x:</p> <ul> <li><code>list-artifacts</code></li> <li><code>capabilities</code></li> <li><code>ingest</code></li> <li><code>materialize</code></li> <li><code>execute</code></li> <li><code>explain</code></li> <li><code>replay</code></li> <li><code>compare</code></li> </ul> <p>Notes:</p> <ul> <li>Flag names and defaults are frozen via snapshot tests; any change requires an explicit test update.</li> <li>Output fields are guaranteed as documented below.</li> </ul>"},{"location":"contracts/backward_compatibility/#api-routes-guaranteed-unchanged","title":"API routes guaranteed unchanged","text":"<p>The following HTTP routes (paths + verbs) are frozen from v0.1.x:</p> <ul> <li><code>GET /capabilities</code></li> <li><code>POST /create</code></li> <li><code>POST /ingest</code></li> <li><code>POST /artifact</code></li> <li><code>POST /execute</code></li> <li><code>POST /explain</code></li> <li><code>POST /replay</code></li> </ul>"},{"location":"contracts/backward_compatibility/#output-fields-guaranteed-unchanged-json-schema","title":"Output fields guaranteed unchanged (JSON schema)","text":"<p>The following output fields are stable across v0.1.x and v0.2.x. They are contractually frozen unless a new major version is released.</p>"},{"location":"contracts/backward_compatibility/#cli-outputs","title":"CLI outputs","text":"<ul> <li><code>list-artifacts</code> \u2192 <code>artifacts</code></li> <li><code>capabilities</code> \u2192 <code>backend</code>, <code>contracts</code>, <code>deterministic_query</code>, <code>supports_ann</code>, <code>replayable</code>, <code>metrics</code>, <code>max_vector_size</code>, <code>isolation_level</code>, <code>execution_modes</code>, <code>ann_status</code>, <code>storage_backends</code>, <code>vector_stores</code></li> <li><code>ingest</code> \u2192 <code>ingested</code></li> <li><code>materialize</code> \u2192 <code>artifact_id</code>, <code>execution_contract</code>, <code>execution_contract_status</code>, <code>replayable</code></li> <li><code>execute</code> \u2192 <code>results</code>, <code>execution_contract</code>, <code>execution_contract_status</code>, <code>replayable</code>, <code>execution_id</code></li> <li><code>explain</code> \u2192 <code>document_id</code>, <code>chunk_id</code>, <code>vector_id</code>, <code>artifact_id</code>, <code>metric</code>, <code>score</code>, <code>execution_contract</code>, <code>execution_contract_status</code>, <code>replayable</code>, <code>execution_id</code></li> <li><code>replay</code> \u2192 <code>matches</code>, <code>original_fingerprint</code>, <code>replay_fingerprint</code>, <code>details</code>, <code>nondeterministic_sources</code>, <code>execution_contract</code>, <code>execution_contract_status</code>, <code>replayable</code>, <code>execution_id</code></li> <li><code>compare</code> \u2192 <code>execution_a</code>, <code>execution_b</code>, <code>overlap_ratio</code>, <code>recall_delta</code>, <code>rank_instability</code>, <code>execution_a_contract</code>, <code>execution_b_contract</code>, <code>execution_a_contract_status</code>, <code>execution_b_contract_status</code></li> </ul>"},{"location":"contracts/backward_compatibility/#api-outputs","title":"API outputs","text":"<ul> <li><code>GET /capabilities</code> \u2192 same fields as CLI <code>capabilities</code></li> <li><code>POST /create</code> \u2192 <code>name</code>, <code>status</code></li> <li><code>POST /ingest</code> \u2192 <code>ingested</code></li> <li><code>POST /artifact</code> \u2192 <code>artifact_id</code>, <code>execution_contract</code>, <code>execution_contract_status</code>, <code>replayable</code></li> <li><code>POST /execute</code> \u2192 <code>results</code>, <code>execution_contract</code>, <code>execution_contract_status</code>, <code>replayable</code>, <code>execution_id</code></li> <li><code>POST /explain</code> \u2192 <code>document_id</code>, <code>chunk_id</code>, <code>vector_id</code>, <code>artifact_id</code>, <code>metric</code>, <code>score</code>, <code>execution_contract</code>, <code>execution_contract_status</code>, <code>replayable</code>, <code>execution_id</code></li> <li><code>POST /replay</code> \u2192 <code>matches</code>, <code>original_fingerprint</code>, <code>replay_fingerprint</code>, <code>details</code>, <code>nondeterministic_sources</code>, <code>execution_contract</code>, <code>execution_contract_status</code>, <code>replayable</code>, <code>execution_id</code></li> </ul>"},{"location":"contracts/backward_compatibility/#canonical-schemas","title":"Canonical schemas","text":"<ul> <li>API request schemas are frozen in <code>api/v1/schema.yaml</code>.</li> <li>The OpenAPI JSON is generated in <code>api/v1/openapi.v1.json</code>.</li> </ul> <p>If you depend on a field, you can rely on this document and the schema file as the legal contract.</p>"},{"location":"contracts/error_style/","title":"Error Message Style Guide","text":"<p>Bijux-Vex error messages must be human-first and actionable. Every message should answer four questions:</p> <ol> <li> <p>What happened State the failure in plain language. No internal jargon unless necessary.</p> </li> <li> <p>Why it happened Explain the immediate cause (missing dependency, mismatch, unavailable backend).</p> </li> <li> <p>How to fix Give a concrete next step a user can take.</p> </li> <li> <p>Where to learn more Point to a doc path in this repository (no external links required).</p> </li> </ol> <p>Keep it short. If a sentence does not help a user act, remove it.</p> <p>Template</p> <pre><code>What happened: &lt;short description&gt;\nWhy: &lt;root cause&gt;\nHow to fix: &lt;specific action&gt;\nWhere to learn more: &lt;doc path&gt;\n</code></pre> <p>Examples</p> <pre><code>What happened: vector store backend unavailable.\nWhy: 'faiss' is not installed.\nHow to fix: pip install \"bijux-vex[vdb]\".\nWhere to learn more: docs/spec/vectorstore_adapter.md\n</code></pre> <pre><code>What happened: deterministic execution refused.\nWhy: ANN mode is non-deterministic.\nHow to fix: choose exact mode or switch to ND explicitly.\nWhere to learn more: docs/spec/determinism_matrix.md\n</code></pre>"},{"location":"contracts/implicitness/","title":"Implicitness Contract (Nothing Is Implicit)","text":"<p>bijux-vex forbids silent behavior. Any decision that can change results, persistence, or replayability must be explicit in the request or configuration.</p>"},{"location":"contracts/implicitness/#what-counts-as-implicit-behavior","title":"What counts as implicit behavior","text":"<p>The following are not allowed without an explicit flag or field:</p> <ul> <li>Choosing a deterministic vs non-deterministic execution contract.</li> <li>Switching to approximate/ANN execution or falling back to exact execution.</li> <li>Persisting vectors or artifacts to any external store.</li> <li>Selecting or mutating execution budgets or randomness bounds.</li> <li>Injecting embeddings or transforming vectors.</li> <li>Replaying against a different plan, ABI, or artifact without a declared contract.</li> </ul>"},{"location":"contracts/implicitness/#what-is-allowed-only-via-explicit-flags-or-fields","title":"What is allowed only via explicit flags or fields","text":"<p>The following behaviors must be opt-in, never default:</p> <ul> <li>Vector store selection (e.g., <code>--vector-store &lt;name&gt;</code>).</li> <li>ANN execution (must declare contract, intent, mode, randomness profile, and budgets).</li> <li>Persistence outside the local execution ledger.</li> <li>Any embedding generation or model selection.</li> </ul>"},{"location":"contracts/implicitness/#enforcement-rules","title":"Enforcement rules","text":"<ul> <li>If a required flag/field is missing, the system refuses to run.</li> <li>There is no silent fallback (e.g., ANN \u2192 exact or VDB \u2192 memory).</li> <li>Deterministic execution must be strict; non-deterministic execution must be bounded or exploratory.</li> </ul> <p>This contract is normative: future features (VDB integration, embeddings, ANN upgrades) must pass this rule or be rejected.</p>"},{"location":"contracts/nd_contract_v1/","title":"ND Contract v1 (Non-Deterministic Execution)","text":"<p>Status: Experimental behavior, stable contract surface. Applies to: <code>ExecutionContract.NON_DETERMINISTIC</code> (see maturity model in <code>ExecutionContract.support_level</code>).</p> <p>This contract formalizes what ND execution is allowed to do, what it must report, and how refusal is represented. ND is not a mode; it is a contract with explicit obligations.</p>"},{"location":"contracts/nd_contract_v1/#1-what-nd-is-allowed-to-do","title":"1) What ND Is Allowed To Do","text":"<p>ND execution may:</p> <ul> <li>Use approximate or heuristic algorithms (ANN, sampling, pruning).</li> <li>Return results that differ in rank order or score from exact execution.</li> <li>Emit bounded divergence instead of bit-identical replay.</li> <li>Refuse execution when declared requirements cannot be met.</li> </ul> <p>ND execution may not:</p> <ul> <li>Proceed without a declared randomness profile and budget.</li> <li>Hide randomness sources or approximation parameters.</li> <li>Silently fall back to exact unless explicitly documented and reported.</li> </ul>"},{"location":"contracts/nd_contract_v1/#2-what-nd-must-report","title":"2) What ND Must Report","text":"<p>Every ND result must include:</p> <ul> <li>Approximation report (<code>ApproximationReport</code>)</li> <li><code>algorithm</code>, <code>algorithm_version</code>, <code>backend</code></li> <li><code>randomness_sources</code></li> <li><code>index_parameters</code> and <code>query_parameters</code></li> <li><code>allowed_rank_jitter</code>, <code>allowed_recall_drop</code></li> <li>Any fallback flags (e.g., <code>deterministic_fallback_used</code>)</li> <li>Determinism report (<code>DeterminismReport</code>)</li> <li><code>randomness_sources</code></li> <li><code>reproducibility_bounds</code></li> <li>Randomness profile (seed and/or declared sources, bounded flag)</li> <li>Budget envelope (latency/memory/error limits, as applicable)</li> </ul> <p>These reports are part of the ND audit trail and must be persisted in execution artifacts/provenance.</p>"},{"location":"contracts/nd_contract_v1/#3-refusal-shape-nd","title":"3) Refusal Shape (ND)","text":"<p>If ND execution is rejected, the refusal payload must be machine-readable and include:</p> <ul> <li><code>reason</code></li> <li><code>message</code></li> <li><code>remediation</code></li> </ul> <p>Examples of ND refusals:</p> <ul> <li><code>reason: determinism_violation</code> \u2192 missing randomness profile or bounds</li> <li><code>reason: backend_capability_missing</code> \u2192 backend cannot honor ND/ANN</li> <li><code>reason: budget_exceeded</code> \u2192 ND budget cannot be satisfied</li> </ul> <p>ND refusals are not silent fallbacks. The caller must decide whether to adjust parameters or switch contracts.</p>"},{"location":"contracts/nd_contract_v1/#4-maturity-model-tie-in","title":"4) Maturity Model Tie-In","text":"<p>The contract surface is stable and enforced:</p> <ul> <li><code>ExecutionContract.NON_DETERMINISTIC.support_level</code> = <code>STABLE_BOUNDED</code></li> <li><code>ExecutionContract.NON_DETERMINISTIC.maturity</code> = <code>EXPERIMENTAL</code></li> </ul> <p>This means the contract is fixed, but the behavior may evolve under explicit, audited changes.</p>"},{"location":"contracts/nd_contract_v1/#5-enforcement-summary","title":"5) Enforcement Summary","text":"<p>ND execution is valid only if all conditions hold:</p> <ul> <li>Explicit contract is <code>NON_DETERMINISTIC</code>.</li> <li>Randomness profile is present (seed and/or sources).</li> <li>Execution budget is present.</li> <li>Approximation + determinism reports are emitted and persisted.</li> <li>Refusals are explicit and structured (no silent fallback).</li> </ul>"},{"location":"contracts/query_contract/","title":"Canonical Query Contract","text":"<p>This contract defines how query results are ordered, filtered, and serialized across all backends. Every backend and adapter must conform.</p>"},{"location":"contracts/query_contract/#ordering-exact","title":"Ordering (Exact)","text":"<ul> <li>Primary sort: ascending distance (lower is better).</li> <li>Tie-breaker: stable order by <code>(distance, vector_id, chunk_id, document_id)</code>.</li> <li>Output ranks are 1-based and must reflect the final ordered list.</li> </ul>"},{"location":"contracts/query_contract/#distance-precision","title":"Distance Precision","text":"<ul> <li>Distances are computed and emitted as <code>float</code> values.</li> <li>Backends must normalize to float32-equivalent precision before sorting.</li> <li>If a backend uses higher precision internally, it must round to float32-equivalent for ordering.</li> </ul>"},{"location":"contracts/query_contract/#top-k-rules","title":"Top-K Rules","text":"<ul> <li>If fewer than <code>k</code> results exist, return all results.</li> <li>If <code>k &lt;= 0</code>, reject the request.</li> <li><code>k</code> applies after ordering and filtering.</li> </ul>"},{"location":"contracts/query_contract/#filtering-semantics","title":"Filtering Semantics","text":"<p>Canonical filter shape (JSON):</p> <pre><code>{\n  \"doc_id\": \"...\",\n  \"chunk_id\": \"...\",\n  \"source_uri\": \"...\",\n  \"tags\": [\"...\"]\n}\n</code></pre> <ul> <li><code>doc_id</code>, <code>chunk_id</code>, <code>source_uri</code> accept either a single string or a list.</li> <li><code>tags</code> must be a list; all tags must be present to match.</li> <li>If a backend supports filters, the filter must be pushed down.</li> <li>If a backend does not support filters, post-filter in memory and log a warning.</li> <li>Unsupported filter keys must be rejected.</li> </ul>"},{"location":"contracts/query_contract/#ann-non-deterministic-mode","title":"ANN / Non-Deterministic Mode","text":"<ul> <li>ANN results may deviate, but ordering must still use the same tie-break rules.</li> <li>If a backend cannot satisfy the requested mode (exact vs ANN), it must refuse.</li> </ul>"},{"location":"contracts/query_contract/#consistency-semantics","title":"Consistency Semantics","text":"<p>Each backend declares its consistency model in capabilities and provenance:</p> <ul> <li><code>read_after_write</code> for local stores (e.g., memory, sqlite, faiss)</li> <li><code>eventual</code> for remote stores (e.g., qdrant)</li> </ul> <p>Backends must not claim stronger guarantees than they provide.</p>"},{"location":"design/contracts/","title":"bijux-vex v1 Contract Spec","text":"<p>bijux-vex is a contract-driven vector execution system with explicit determinism semantics. Every surface binds to a small set of contracts; anything outside these contracts is rejected.</p>"},{"location":"design/contracts/#canonicalization-ids","title":"Canonicalization + IDs","text":"<ul> <li>Canonical bytes and fingerprints are stable and versioned.</li> <li>Modules: <code>src/bijux_vex/core/canon.py</code>, <code>src/bijux_vex/core/ids.py</code>, <code>src/bijux_vex/core/types.py</code>.</li> </ul>"},{"location":"design/contracts/#tx-authz-audit","title":"Tx + authz + audit","text":"<ul> <li>All mutations run inside a <code>Tx</code>, with explicit authz checks and tamper-evident audit chaining.</li> <li>Modules: <code>src/bijux_vex/contracts/tx.py</code>, <code>src/bijux_vex/contracts/authz.py</code>, <code>src/bijux_vex/domain/provenance/audit.py</code>.</li> </ul>"},{"location":"design/contracts/#executionartifact","title":"ExecutionArtifact","text":"<ul> <li>Portable description of an execution artifact: fingerprints, metric, scoring version, <code>ExecutionContract</code>, and replayability.</li> <li>Modules: <code>src/bijux_vex/core/types.py</code> (<code>ExecutionArtifact</code>), <code>src/bijux_vex/core/ids.py</code>, <code>src/bijux_vex/core/invariants.py</code>.</li> </ul>"},{"location":"design/contracts/#executionrequest-determinism","title":"ExecutionRequest determinism","text":"<ul> <li>Identical execution requests over identical corpora yield identical ranked results under the deterministic contract.</li> <li>Modules: <code>src/bijux_vex/core/types.py</code>, <code>src/bijux_vex/domain/execution_requests/scoring.py</code>, <code>tests/conformance/execution_request_determinism.py</code>.</li> </ul>"},{"location":"design/contracts/#explainability-replay","title":"Explainability + replay","text":"<ul> <li>Results must be explainable doc\u2192chunk\u2192vector\u2192artifact\u2192score with provenance that carries <code>execution_contract</code>, <code>nondeterministic_sources</code>, and <code>lossy_dimensions</code>.</li> <li><code>ReplayOutcome</code> declares divergence; deterministic runs must match, non-deterministic runs must mark lossiness.</li> <li>Modules: <code>src/bijux_vex/domain/provenance/audit.py</code>, <code>src/bijux_vex/domain/provenance/lineage.py</code>, <code>src/bijux_vex/domain/provenance/replay.py</code>, <code>tests/conformance/test_execution_contracts.py</code>.</li> </ul>"},{"location":"design/contracts/#backend-isolation","title":"Backend isolation","text":"<ul> <li>Backend-specific knobs stay below <code>src/bijux_vex/infra/adapters/</code>.</li> <li>Forbidden leakage: backend table names, ANN parameters, backend-native IDs, or backend-specific consistency/authz semantics.</li> <li>Adapters translate contracts to backend knobs; the conformance suite must run unchanged across backends.</li> </ul>"},{"location":"design/determinism/","title":"Determinism Rules","text":"<p>These rules define the determinism gate. Identical inputs + configuration must yield byte-identical artifacts. They apply to the deterministic execution contract only; ANN mode is documented separately in <code>execution_contracts.md</code> and explicitly forfeits replayability.</p>"},{"location":"design/determinism/#canonical-json","title":"Canonical JSON","text":"<ul> <li>Serialize with sorted keys.</li> <li>Lists must be emitted in a stable order; upstream ordering must be deterministic before serialization.</li> <li>No implicit defaults: every serialized field is explicit and ordered.</li> <li>Encoding is UTF-8 without BOM; no trailing whitespace.</li> </ul>"},{"location":"design/determinism/#float-normalization","title":"Float Normalization","text":"<ul> <li>NaN and \u00b1Inf are forbidden; validation must reject them.</li> <li>Finite floats are normalized via canonical JSON string form produced by Python <code>repr</code> on <code>float</code> (deterministic across runs for finite values).</li> <li>No rounding/quantization beyond the source value; callers must pre-quantize if needed.</li> </ul>"},{"location":"design/determinism/#ranking-tie-breaks","title":"Ranking Tie-Breaks","text":"<ul> <li>Ranking order is <code>(score, vector_id, chunk_id, document_id)</code> ascending by score, then lexicographic by IDs.</li> <li>Scores that compare equal after normalization must still be ordered by these explicit keys.</li> <li>Backends must not introduce hidden randomness; any deterministic seed must be part of the query spec.</li> </ul>"},{"location":"design/determinism/#example-executable","title":"Example (executable)","text":"<p>from bijux_vex.core.identity.ids import fingerprint fp1 = fingerprint({\"doc\": 1}) fp2 = fingerprint({\"doc\": 1}) fp1 == fp2 True</p>"},{"location":"design/execution_contracts/","title":"Execution Contracts","text":"<p>bijux-vex supports two explicit execution contracts. There is no default: callers must choose the contract when materializing execution artifacts and when issuing execution requests.</p>"},{"location":"design/execution_contracts/#deterministic","title":"Deterministic","text":"<ul> <li>Exact execution; vector scores are stable and tie-broken deterministically.</li> <li>Replayable: execution requests can be re-run and compared byte-for-byte via fingerprints.</li> <li>Execution artifacts and provenance record <code>execution_contract=deterministic</code> and remain fully explainable.</li> </ul>"},{"location":"design/execution_contracts/#non-deterministic-ann","title":"Non-deterministic (ANN)","text":"<ul> <li>Uses declared approximate runners; results may differ across runs even with identical inputs.</li> <li>Replay is allowed but must declare divergence via <code>nondeterministic_sources</code>, <code>lossy_dimensions</code>, and replay details.</li> <li>Treated as an operational escape hatch, not the primary mode; experimental until ANN graduation criteria are met. Deterministic and non-deterministic contracts cannot mix on the same artifact ID.</li> </ul>"},{"location":"design/execution_contracts/#positioning","title":"Positioning","text":"<ul> <li>Deterministic mode is the first-class experience and the baseline for conformance.</li> <li>ANN is opt-in per execution artifact and must refuse deterministic contracts.</li> <li>Provenance is never silent: lossy paths must describe why an exact replay is impossible.</li> </ul>"},{"location":"design/glossary/","title":"Glossary","text":"<ul> <li>Document: Source text unit provided by users.</li> <li>Chunk: Deterministic slice of a document with stable ordinal.</li> <li>Vector: Numeric representation associated with a chunk and model.</li> <li>ExecutionArtifact: Portable description of an execution build and its provenance.</li> <li>ExecutionContract: Required determinism contract for every artifact and execution request.</li> <li>Backend: Adapter implementation of execution resources.</li> <li>Tx: Transaction boundary required for any mutation.</li> <li>Authz: Authorization hook invoked before mutations.</li> <li>AuditRecord: Tamper-evident record chaining mutation history.</li> <li>Determinism: Contract where replay MUST be bit-identical; hidden randomness forbidden.</li> <li>Non-determinism: Contract where randomness MUST be declared; replay checks envelopes, not equality.</li> <li>Replay: Re-running the same plan under the same contract; deterministic \u21d2 equality, ND \u21d2 bounded envelope. Replayable means re-execution is possible, not that results are cached.</li> <li>Stability: Deterministic surfaces are frozen; ND/ANN is stable at the contract level but experimental in behavior (outcomes vary within declared bounds).</li> <li>Reproducibility: Ability to obtain the same execution behavior under the same plan/contract/randomness; stronger than \u201csimilar results.\u201d</li> <li>Determinism vs reproducibility: determinism demands identical outputs; ND reproducibility means divergence stays within the recorded approximation envelope.</li> </ul>"},{"location":"design/non_goals/","title":"Non-goals (hard exclusions)","text":"<p>bijux-vex is a vector execution engine. The following are explicitly out of scope:</p> <ul> <li>Not a vector database or general-purpose datastore.</li> <li>Not a model runner or embedding factory.</li> <li>Not a retrieval framework or RAG orchestration layer.</li> <li>Not a streaming/online serving tier or SLA scheduler.</li> <li>Not an auto-tuner for ANN parameters.</li> <li>Not a distributed coordination or sharding system.</li> <li>Not a streaming/async result delivery mechanism; executions are bounded, audited batches only.</li> </ul> <p>Any change that drifts into these areas must be rejected unless the scope is explicitly revised.</p>"},{"location":"design/rejected_alternatives/","title":"Rejected design alternatives","text":"<p>These are intentionally rejected to prevent future regressions.</p> <ul> <li>VDB-style CRUD APIs: rejected; bijux-vex is an execution engine, not storage. Silent persistence semantics would dilute contracts.</li> <li>Implicit retries on invariants: rejected; invariants are terminal programmer/system faults. Retrying hides bugs and corrupts provenance.</li> <li>Silent ND fallback to deterministic: rejected; violates declared contracts. ND without ANN must fail explicitly.</li> <li>Hidden randomness: rejected; all randomness must be declared via <code>RandomnessProfile</code> and audited.</li> <li>Adaptive schema drift: rejected; OpenAPI/ABI changes require additive evolution or version bumps, never silent drift.</li> </ul>"},{"location":"design/scope/","title":"Scope","text":"<p>bijux-vex delivers contract-driven vector execution semantics (not a database). v1 focuses on:</p> <ul> <li>deterministic canonicalization and IDs</li> <li>transactional mutation with authz + audit</li> <li>backend-agnostic execution resources and conformance suite</li> <li>reference memory + SQLite adapters with explicit execution contracts</li> </ul> <p>Excluded (v1): streaming ingestion, distributed execution, on-device embedding inference, backend tuning controls above adapters.</p>"},{"location":"design/vdb_comparison/","title":"Why bijux-vex is not a vector DB (concrete comparison)","text":"<p>bijux-vex is an execution engine; vector DBs are storage/serving systems. Key differences:</p> <ul> <li>Contracts first: every execution declares determinism vs non-determinism; vector DBs often hide approximation trade-offs.</li> <li>Replay semantics: deterministic replay is enforced; ND replay is envelope-validated. Most vector DBs offer best-effort behavior without provenance.</li> <li>Provenance: executions emit lineage, randomness, and approximation metadata as a first-class artifact; vector DBs treat queries as transient.</li> <li>Capability honesty: backends must declare support for ND and determinism; vector DBs frequently downgrade silently.</li> <li>No CRUD semantics: bijux-vex does not expose database operations; ingestion/materialization are execution-scoped, not general storage APIs.</li> </ul> <p>Use bijux-vex when you need audited, contract-bound vector execution. Use a vector DB when you need a managed serving tier with CRUD and scale-out storage.</p>"},{"location":"design/vector_store_opt_in/","title":"Vector Store Opt-In Design (explicit only)","text":"<p>This design prevents silent persistence. Vector store usage must be explicit in both CLI and API.</p>"},{"location":"design/vector_store_opt_in/#cli","title":"CLI","text":"<ul> <li>Flag: <code>--vector-store &lt;name&gt;</code></li> <li>Default is local memory when the flag is omitted.</li> <li>External vector stores are only used when <code>--vector-store</code> is set.</li> </ul>"},{"location":"design/vector_store_opt_in/#api","title":"API","text":"<ul> <li>Field: <code>vector_store</code> in execution/materialization payloads.</li> <li>Omission means no external store (local memory only).</li> </ul>"},{"location":"design/vector_store_opt_in/#behavior","title":"Behavior","text":"<ul> <li>If <code>vector_store</code> is set, the adapter is used for persistence/query.</li> <li>If <code>vector_store</code> is not set, the system uses only the execution ledger and in-memory/vector sources.</li> <li>No silent fallback between stores.</li> </ul>"},{"location":"design/vector_store_opt_in/#rationale","title":"Rationale","text":"<ul> <li>Guarantees that persistence is always explicit.</li> <li>Prevents accidental data retention or storage semantics being inferred.</li> <li>Aligns with the \u201cNothing Is Implicit\u201d contract.</li> </ul>"},{"location":"design/why_vector_execution/","title":"Why vector execution \u2260 vector storage","text":"<p>bijux-vex is a vector execution engine. It treats every query as an explicit execution with a contract, an intent, and a surfaced randomness profile. Storing vectors is necessary but insufficient; the value is in how executions are planned, run, compared, and replayed.</p>"},{"location":"design/why_vector_execution/#why-determinism-matters","title":"Why determinism matters","text":"<ul> <li>Deterministic executions (DETERMINISTIC) must replay exactly. bijux-vex refuses to run them through approximate paths and fingerprints every execution.</li> <li>Non-deterministic executions (NON_DETERMINISTIC) declare their loss surface up front: randomness sources, replay bounds, and provenance flags.</li> </ul>"},{"location":"design/why_vector_execution/#why-approximation-must-be-explicit","title":"Why approximation must be explicit","text":"<ul> <li>ANN is only allowed when the execution intent justifies it (exploratory search, production retrieval with budgets).</li> <li>RandomnessSurface captures the sources of non-determinism so divergence is declared, not hidden.</li> </ul>"},{"location":"design/why_vector_execution/#why-existing-vdbs-conflate-concerns","title":"Why existing VDBs conflate concerns","text":"<ul> <li>Most vector databases merge storage and execution, hiding algorithm choice and randomness behind \u201cquery\u201d APIs.</li> <li>They rarely expose execution lineage, making replay and cross-backend comparison brittle.</li> </ul>"},{"location":"design/why_vector_execution/#how-bijux-vex-fits-the-ecosystem","title":"How bijux-vex fits the ecosystem","text":"<ul> <li>bijux-vex focuses on vector execution with explicit determinism semantics; reasoning and RAG concerns live elsewhere. Execution traces, contracts, and intents remain first-class here for vector workloads.</li> <li>VectorExecution is the unit of meaning here: it records the request, contract, backend, algorithm, parameters, and randomness surface. Artifacts reference executions by hash, keeping lineage auditable.</li> </ul> <p>Use bijux-vex when you need to compare exact vs approximate runs, measure divergence, and keep replayability honest. Don\u2019t use it as a generic datastore or a serving tier\u2014it\u2019s an execution lab, not a database.</p>"},{"location":"examples/audit_narrative/","title":"Audit narrative (truth trace)","text":"<p>Flow:</p> <pre><code>request (contract + intent + budget)\n  \u2192 session (state machine binds randomness + resources)\n  \u2192 plan (fingerprinted, capability-checked)\n  \u2192 execution (algorithm + contract + randomness applied)\n  \u2192 result (deterministic/ND + ApproximationReport + DeterminismReport)\n  \u2192 audit (ledger + chain hash)\n  \u2192 replay/compare (deterministic \u21d2 equality, ND \u21d2 envelope) or refusal\n</code></pre> <p>Key checkpoints:</p> <ul> <li>Contract/intent validated up front; ND without ANN raises <code>NDExecutionUnavailableError</code>.</li> <li>Plan immutability enforced before execution (fingerprint check).</li> <li>Provenance persisted with approximation + randomness metadata.</li> <li>Replay refuses without provenance; compare requires matching provenance lineage.</li> </ul>"},{"location":"examples/canonical/","title":"Canonical vector execution pipeline","text":"<p>This is the single example to understand bijux-vex:</p> <ol> <li>ingest a small corpus (document + vector)</li> <li>materialize an execution artifact (deterministic)</li> <li>execute deterministically</li> <li>execute non-deterministically with randomness declared</li> <li>compare the two executions</li> <li>explain a result</li> </ol> <p>Everything else in bijux-vex is this pipeline with different knobs.</p>"},{"location":"examples/contract_violation/","title":"Contract violation example","text":"<p>This shows a minimal invariant failure and the exact error raised.</p>"},{"location":"examples/contract_violation/#scenario","title":"Scenario","text":"<ul> <li>Artifact built for deterministic execution.</li> <li>Request attempts non-deterministic execution without ANN support.</li> </ul>"},{"location":"examples/contract_violation/#command","title":"Command","text":"<pre><code>bijux vex execute --artifact-id art-1 --vector \"[0,1,0]\" --top-k 1 \\\n  --execution-contract non_deterministic --execution-intent exploratory_search --execution-mode bounded \\\n  --randomness-seed 1 --randomness-sources reference_ann_hnsw --randomness-bounded \\\n  --max-latency-ms 10 --max-memory-mb 10 --max-error 0.5\n</code></pre>"},{"location":"examples/contract_violation/#expected-result","title":"Expected result","text":"<ul> <li>Execution is rejected with <code>NDExecutionUnavailableError</code>.</li> <li>Error message: <code>Non-deterministic execution requested without ANN support</code>.</li> <li>Provenance/audit records the failure; no execution occurs.</li> </ul>"},{"location":"examples/contract_violation/#why-it-is-forbidden","title":"Why it is forbidden","text":"<ul> <li>Non-deterministic execution requires an ANN backend to honor the contract.</li> <li>Silent fallback to deterministic would violate declared execution semantics.</li> <li>ND execution is stable_bounded at the contract level but still experimental in behavior; refusal without ANN keeps the contract honest.</li> <li>Error message is stable and public: <code>Non-deterministic execution requested without ANN support</code>.</li> </ul>"},{"location":"examples/nd_reproducibility/","title":"Non-deterministic reproducibility experiment","text":"<p>This walkthrough shows what changes and what stays bounded when running the same ND execution repeatedly. ND behavior is experimental; use this to observe and audit variance.</p>"},{"location":"examples/nd_reproducibility/#setup","title":"Setup","text":"<pre><code>bijux vex ingest --doc \"hi\" --vector \"[0.0, 0.0]\"\nbijux vex materialize --execution-contract non_deterministic\n</code></pre>"},{"location":"examples/nd_reproducibility/#run-the-same-nd-execution-3-times","title":"Run the same ND execution 3 times","text":"<pre><code>for i in 1 2 3; do\n  bijux vex execute --artifact-id art-1 --vector \"[0.0,0.0]\" --top-k 1 \\\n    --execution-contract non_deterministic --execution-intent exploratory_search --execution-mode bounded \\\n    --randomness-seed $i --randomness-sources reference_ann_hnsw --randomness-bounded \\\n    --max-latency-ms 5 --max-memory-mb 5 --max-error 0.2\ndone\n</code></pre>"},{"location":"examples/nd_reproducibility/#what-you-should-see","title":"What you should see","text":"<ul> <li>Results may vary in rank/score order, but <code>ApproximationReport</code> records:</li> <li>algorithm, version, backend</li> <li><code>randomness_sources</code>, <code>random_seed</code></li> <li><code>recall_at_k</code>, <code>rank_displacement</code>, <code>distance_error</code></li> <li>Provenance shows the randomness envelope and ND contract.</li> </ul> <p>Sample truncated output (3 runs):</p> <pre><code>{\"approximation\":{\"algorithm\":\"hnswlib\",\"rank_displacement\":0.0,\"recall_at_k\":1.0,\"random_seed\":1},\"results\":[{\"rank\":1,\"score\":0.0,\"vector_id\":\"vec-0\"}]}\n{\"approximation\":{\"algorithm\":\"hnswlib\",\"rank_displacement\":0.0,\"recall_at_k\":1.0,\"random_seed\":2},\"results\":[{\"rank\":1,\"score\":0.0,\"vector_id\":\"vec-0\"}]}\n{\"approximation\":{\"algorithm\":\"hnswlib\",\"rank_displacement\":0.0,\"recall_at_k\":1.0,\"random_seed\":3},\"results\":[{\"rank\":1,\"score\":0.0,\"vector_id\":\"vec-0\"}]}\n</code></pre>"},{"location":"examples/nd_reproducibility/#replay-envelope","title":"Replay envelope","text":"<p>Replay of ND executions does not expect equality. It validates that observed divergence stays within the recorded approximation bounds; otherwise replay fails with a contract violation.</p>"},{"location":"examples/overview/","title":"Examples overview","text":"<p>Use these scenarios to learn the system quickly. Follow them in order.</p> <p>1) Exact execution: <code>spec/examples/exact_execution.md</code></p> <ul> <li> <p>Run a deterministic query, inspect replayable artifacts. 2) ANN execution (experimental): <code>spec/examples/ann_execution.md</code></p> </li> <li> <p>Run a non-deterministic query with an ANN runner, see approximation reports. 3) Deterministic replay: <code>spec/examples/deterministic_replay.md</code></p> </li> <li> <p>Prove deterministic outputs match across runs. 4) ND execution with audit: <code>spec/examples/nd_execution_with_audit.md</code></p> </li> <li> <p>Inspect randomness, approximation metadata, and replay envelopes. 5) Forcing case: <code>spec/examples/forcing_case.md</code></p> </li> <li> <p>Combined budget exhaustion + fallback + divergence audit. 6) Limitations and failure modes: <code>spec/examples/ugly_truth.md</code></p> </li> <li> <p>Understand how and why executions can fail. 7) Contract violation: <code>examples/contract_violation.md</code></p> </li> <li> <p>Intentional misuse: ND requested without ANN support returns <code>NDExecutionUnavailableError</code>.</p> </li> </ul> <p>Tips:</p> <ul> <li>Cross-check each example with the API schema (<code>api/v1/schema.yaml</code>) if using HTTP.</li> <li>Keep the non-goals in mind: this is not a vector DB or RAG system.</li> </ul>"},{"location":"guides/nd_production/","title":"ND In Production","text":"<p>This guide shows how to run non-deterministic (ND) execution safely and intentionally.</p>"},{"location":"guides/nd_production/#choose-a-profile","title":"Choose A Profile","text":"<p>Use an explicit profile to set baseline quality:</p> <pre><code>bijux vex execute \\\n  --execution-contract non_deterministic \\\n  --execution-intent exploratory_search \\\n  --execution-mode bounded \\\n  --randomness-seed 42 \\\n  --randomness-sources ann_index \\\n  --nd-profile balanced \\\n  --vector '[0.1,0.2]' \\\n  --top-k 5\n</code></pre> <p>Profiles: <code>fast</code> trades recall for latency, <code>balanced</code> is the default tradeoff, <code>accurate</code> prioritizes recall.</p>"},{"location":"guides/nd_production/#set-a-recall-target","title":"Set A Recall Target","text":"<pre><code>--nd-target-recall 0.95\n</code></pre> <p>If the backend cannot honor the target, the request is refused with a remediation hint.</p>"},{"location":"guides/nd_production/#enforce-a-latency-budget","title":"Enforce A Latency Budget","text":"<pre><code>--nd-latency-budget-ms 20\n</code></pre> <p>When latency exceeds the budget, ND may degrade in a declared ladder: reduce <code>k</code>, switch profile, or refuse.</p>"},{"location":"guides/nd_production/#tune-profiles-quickly","title":"Tune Profiles Quickly","text":"<p>Run a small tuning session against current data:</p> <pre><code>bijux vex nd tune --vector-store faiss --top-k 10 --samples 10\n</code></pre> <p>This reports per-profile latency and recommends a profile for your workload.</p>"},{"location":"guides/nd_production/#enable-witness-queries","title":"Enable Witness Queries","text":"<p>Witness queries sample exact results for auditing.</p> <pre><code>--nd-witness-rate 0.1 \\\n--nd-witness-sample-k 3\n</code></pre> <p>Witness results are recorded in provenance.</p>"},{"location":"guides/nd_production/#read-nd-stability-signals","title":"Read ND Stability Signals","text":"<p>ND results emit stability metrics:</p> <ul> <li><code>rank_instability</code></li> <li><code>distance_margin</code></li> <li><code>similarity_entropy</code></li> <li><code>witness_report</code></li> </ul> <p>Use them to validate whether ND is appropriate for your workload.</p>"},{"location":"guides/nd_production/#calibrated-score-ranges","title":"Calibrated Score Ranges","text":"<p>ND results include calibrated score ranges derived from the active metric. Cross-backend score comparisons only make sense when metric + normalization are identical.</p>"},{"location":"guides/nd_production/#replay-semantics","title":"Replay Semantics","text":"<p>ND replay is only attempted when a seed is provided:</p> <pre><code>--randomness-seed 123\n</code></pre> <p>If you declare <code>--randomness-non-replayable</code>, replay is refused by design.</p>"},{"location":"guides/nd_production/#strict-replay-checks","title":"Strict Replay Checks","text":"<p>ND replay refuses if the ANN index hash changes between runs. This prevents false claims of replayability when the index has drifted.</p>"},{"location":"guides/nd_production/#build-ann-indexes-explicitly","title":"Build ANN Indexes Explicitly","text":"<p>Separate index building from query:</p> <pre><code>bijux vex materialize --execution-contract non_deterministic --index-mode ann\n</code></pre> <p>To rebuild:</p> <pre><code>bijux vex vdb rebuild --vector-store faiss --mode ann\n</code></pre> <p>If you need on-demand builds for development, opt in:</p> <pre><code>--nd-build-on-demand\n</code></pre>"},{"location":"guides/nd_production/#warmup-queries","title":"Warmup Queries","text":"<p>Use warmup queries to preheat caches and reduce first-query latency:</p> <pre><code>--nd-warmup-queries warmup_vectors.json\n</code></pre> <p><code>warmup_vectors.json</code> should be a JSON array of vectors.</p>"},{"location":"guides/nd_production/#outlier-handling","title":"Outlier Handling","text":"<p>ND can refuse low-signal queries:</p> <pre><code>--nd-outlier-threshold 0.2 --nd-adaptive-k\n</code></pre> <p>When the best neighbors are below the threshold, the run returns a <code>nd_no_confident_neighbors</code> reason instead of low-quality results.</p>"},{"location":"guides/nd_production/#slo-reporting","title":"SLO Reporting","text":"<p>ND runs report whether they met:</p> <ul> <li><code>nd_latency_budget_ms</code></li> <li><code>nd_target_recall</code> (when witness is enabled)</li> </ul> <p>This makes alerting and dashboards straightforward.</p>"},{"location":"guides/nd_production/#failure-guardrails","title":"Failure Guardrails","text":"<p>If the ND backend fails repeatedly, a circuit breaker refuses ND requests for a short cooldown. Use <code>--trace</code> to view events.</p>"},{"location":"legal/licensing/","title":"Licensing","text":"<ul> <li>Code: MIT License (see <code>LICENSE</code> in the repository root).</li> <li>Documentation and configuration assets: CC0-1.0 unless otherwise noted.</li> </ul> <p>By contributing, you agree to license your contributions under the same terms. If you include third-party code or assets, ensure their licenses are compatible and documented.</p>"},{"location":"maintainer/ann_runner_audit/","title":"ANN Runner Audit (reference implementation)","text":"<p>Scope: <code>ReferenceAnnRunner</code> (<code>src/bijux_vex/infra/adapters/ann_reference.py</code>).</p>"},{"location":"maintainer/ann_runner_audit/#randomness-sources","title":"Randomness sources","text":"<ul> <li><code>hnswlib</code> index construction and search order (library-level nondeterminism).</li> <li>Seed usage is fixed (<code>set_seed(0)</code>), but does not guarantee determinism across platforms.</li> <li>Candidate truncation path uses deterministic ordering but is still labeled ANN.</li> </ul>"},{"location":"maintainer/ann_runner_audit/#non-reproducible-steps","title":"Non-reproducible steps","text":"<ul> <li>Index build depends on vector insertion order and library behavior.</li> <li>HNSW graph structure may vary across builds even with a fixed seed.</li> <li>If index persistence is enabled, replay depends on external index file state.</li> </ul>"},{"location":"maintainer/ann_runner_audit/#audit-gaps-to-close-before-ann-graduation","title":"Audit gaps (to close before ANN graduation)","text":"<ul> <li>No explicit provenance for index build parameters beyond <code>M</code> and <code>ef_search</code>.</li> <li>No checksum/fingerprint for index file contents.</li> <li>No capture of library version or hardware characteristics.</li> <li>No explicit declaration of whether the truncation fallback was used.</li> </ul>"},{"location":"maintainer/ann_runner_audit/#notes","title":"Notes","text":"<ul> <li>The runner labels <code>randomness_sources = (\"reference_ann_hnsw\",)</code>.</li> <li>ANN remains experimental until the gaps above are addressed (see <code>docs/spec/ann_graduation_criteria.md</code>).</li> </ul>"},{"location":"maintainer/benchmark_truth_table/","title":"Benchmark Truth Table","text":"<p>This document defines what Bijux Vex benchmarks measure, what they do not claim, and when results are comparable.</p>"},{"location":"maintainer/benchmark_truth_table/#measurements","title":"Measurements","text":"<ul> <li> <p><code>exact</code>: Measures deterministic exact kNN latency and throughput on a fixed dataset. Includes warmup time and steady-state timings.</p> </li> <li> <p><code>ann</code>: Measures ND latency and quality signals (<code>overlap@k</code>, instability estimates) under bounded ND settings. Quality is estimated from sampled queries.</p> </li> </ul>"},{"location":"maintainer/benchmark_truth_table/#non-claims","title":"Non-Claims","text":"<ul> <li>Benchmarks do not certify production SLO compliance.</li> <li>ANN results do not imply full recall without witness verification.</li> <li>Results are not comparable across different datasets or dimensions.</li> </ul>"},{"location":"maintainer/benchmark_truth_table/#comparability-rules","title":"Comparability Rules","text":"<ul> <li>Compare only within the same dataset size, dimension, and query count.</li> <li>Compare only within the same backend + mode pairing.</li> <li>Treat <code>status: todo</code> baselines as placeholders.</li> </ul>"},{"location":"maintainer/benchmark_truth_table/#baseline-policy","title":"Baseline Policy","text":"<ul> <li>Baselines are committed as data.</li> <li>CI treats regressions as warnings until <code>status</code> is <code>measured</code>.</li> <li>Heavy benchmarks should be run on a dedicated host (not CI).</li> </ul>"},{"location":"maintainer/benchmarks/","title":"Benchmark Runs","text":"<p>See <code>docs/maintainer/benchmark_truth_table.md</code> for what each benchmark measures and does not claim.</p>"},{"location":"maintainer/benchmarks/#baselines","title":"Baselines","text":"<ul> <li>Baselines live under <code>benchmarks/baselines/</code>.</li> <li>The CI matrix expects entries for memory, FAISS, and Qdrant (exact + ann).</li> <li>Replace <code>status: todo</code> placeholders after running on a dedicated host.</li> </ul>"},{"location":"maintainer/benchmarks/#run-locally","title":"Run Locally","text":"<pre><code>make install\n.venv/bin/python -m bijux_vex.boundaries.cli.app bench --store vdb --vector-store faiss --mode exact\n.venv/bin/python -m bijux_vex.boundaries.cli.app bench --store vdb --vector-store faiss --mode ann\n</code></pre>"},{"location":"maintainer/benchmarks/#qdrant-local","title":"Qdrant (Local)","text":"<p>Qdrant benchmarks can run without Docker using the in-memory client:</p> <pre><code>.venv/bin/python -m bijux_vex.boundaries.cli.app bench --store vdb --vector-store qdrant --vector-store-uri :memory: --mode exact\n.venv/bin/python -m bijux_vex.boundaries.cli.app bench --store vdb --vector-store qdrant --vector-store-uri :memory: --mode ann\n</code></pre>"},{"location":"maintainer/benchmarks/#qdrant-docker","title":"Qdrant (Docker)","text":"<p>If you prefer a local service:</p> <pre><code>docker run --rm -p 6333:6333 qdrant/qdrant:latest\n</code></pre> <p>Then run the same commands without <code>--vector-store-uri :memory:</code>.</p>"},{"location":"maintainer/benchmarks/#todos","title":"TODOs","text":"<ul> <li>TODO: generate FAISS exact/ann baselines on a faster host.</li> <li>TODO: generate Qdrant exact/ann baselines on a faster host.</li> <li>TODO: generate FAISS 100k baselines on a faster host.</li> </ul>"},{"location":"maintainer/compatibility_breaks/","title":"What WILL break compatibility","text":"<p>Changes that REQUIRE a major version bump:</p> <ul> <li>Changing deterministic execution semantics or ABI.</li> <li>Removing or renaming public API modules: <code>bijux_vex.core.types</code>, <code>bijux_vex.core.contracts.execution_contract</code>, <code>bijux_vex.core.runtime.vector_execution</code>, <code>bijux_vex.contracts.resources</code>, <code>bijux_vex.services.execution_engine</code>, <code>bijux_vex.api.v1</code>.</li> <li>Changing public error types or their messages for deterministic paths.</li> <li>Changing OpenAPI v1 schema in a non-additive way.</li> <li>Altering provenance structure such that existing artifacts cannot be replayed/validated.</li> </ul> <p>Changes that do NOT require a major bump (but still need tests/docs):</p> <ul> <li>Additive OpenAPI v1 fields with safe defaults.</li> <li>New internal modules or refactors that do not touch public surfaces.</li> <li>Performance improvements that preserve deterministic behavior and ND envelopes.</li> <li>Additional examples or docs that do not alter contracts.</li> </ul>"},{"location":"maintainer/contributor_architecture_invariants/","title":"Contributor Architecture &amp; Invariants","text":"<p>This guide explains where guarantees live and how to extend Bijux-Vex safely.</p> <p>Core invariants</p> <ul> <li>Deterministic execution is exact and replayable.</li> <li>ND execution must declare randomness and bounds.</li> <li>No silent fallbacks or implicit defaults.</li> <li>Provenance is always emitted for executed requests.</li> </ul> <p>Where logic must never go</p> <ul> <li>Do not embed policy decisions inside adapters.</li> <li>Do not bypass ND planning in runners.</li> <li>Do not emit unstructured errors.</li> </ul> <p>How to add a vector store</p> <ul> <li>Implement the adapter interface.</li> <li>Declare capabilities and consistency semantics.</li> <li>Add redaction rules for credentials.</li> <li>Add conformance tests.</li> </ul> <p>How to add an ND runner</p> <ul> <li>Declare determinism characteristics and randomness sources.</li> <li>Implement budget enforcement and parameter mapping.</li> <li>Emit ND quality metrics and confidence labels.</li> </ul> <p>How to add an embedding provider</p> <ul> <li>Declare determinism status.</li> <li>Emit full provider metadata.</li> <li>Respect caching and redaction rules.</li> </ul> <p>Running the full test suite safely</p> <ul> <li><code>make lint quality security test docs api</code></li> <li>Install extras for FAISS, Qdrant, and ND runners if you want all tests to run.</li> </ul>"},{"location":"maintainer/debt_log/","title":"Architectural debt log","text":"<ul> <li>Layer gap: Services vs orchestration remain split for public surface stability. Remove when CLI/tests can depend directly on <code>_orchestrator</code>.</li> <li>Policy flattening: Temporary removal of <code>core/policy</code>; revisit when compliance rules need isolation.</li> <li>Error-as-value: Only one path uses <code>ExecutionOutcome</code>; widen once callers migrate away from exceptions.</li> <li>Replay semantics: ND replay now re-executes and may diverge; formalize envelopes before widening backend set.</li> </ul>"},{"location":"maintainer/deletion_policy/","title":"Deletion policy","text":"<ul> <li>Prefer deletion over abstraction when:</li> <li>invariants can be enforced without an extra layer</li> <li>an extension seam is unused across releases</li> <li>a feature is undocumented or not backed by specs/tests</li> <li>Any new abstraction must list the invariant it enforces; otherwise delete or inline.</li> <li>Deprecations: mark in docs/spec/identity.md and remove in next minor unless ecosystem-bound.</li> <li>Freeze rule: dead code or unused flags are removed before tagging; no \u201cmaybe later\u201d retention.</li> </ul>"},{"location":"maintainer/design_diary/","title":"Design diary (traceability)","text":"<p>This diary records design pressures, reversals, and lessons learned. Update it only when something hurts.</p> <ul> <li>ANN integration: kept a single reference runner to avoid taxonomy sprawl; randomness surfaces must be explicit and audited.</li> <li>Replay semantics: deterministic is replayable; ND is envelope-validated only. Storing <code>replayable</code> was removed to prevent drift.</li> <li>Capability honesty: backends must declare <code>supports_ann</code>; dishonesty now fails fast with structured errors.</li> <li>Retention limits: ledgers enforce artifact/result caps to avoid slow operational leaks.</li> </ul> <p>When making changes, add a short bullet describing the pressure and the chosen trade-off.</p>"},{"location":"maintainer/do_not_optimize/","title":"Do not optimize (by design)","text":"<p>These are intentionally \u201cheavy\u201d and must stay that way:</p> <ul> <li>Canon normalization and fingerprinting: preserve provenance integrity.</li> <li>Invariant checks: fail fast; do not bypass or \u201cretry\u201d invariants.</li> <li>Execution state machine: explicit transitions prevent ghost states.</li> <li>Replay requiring provenance: no shortcuts; missing provenance must fail.</li> <li>ND refusal without ANN: keeps contracts honest; no silent fallback.</li> </ul> <p>Optimizing away these checks is a correctness regression.</p>"},{"location":"maintainer/docs_freeze_checklist/","title":"Documentation freeze checklist","text":"<p>Use this before tagging any v0.1.x release. Documentation is a release artifact.</p> <ul> <li>[ ] <code>mkdocs build --strict</code> passes with zero warnings.</li> <li>[ ] All Markdown files are reachable from navigation (see <code>tests/unit/test_docs_invariants.py</code>).</li> <li>[ ] README links and badges validated (docs, spec, API, examples, license, start_here).</li> <li>[ ] <code>docs/user/start_here.md</code> present and linked from README and docs home.</li> <li>[ ] API contract: <code>api/v1/schema.yaml</code> committed; <code>make api-freeze</code> produces no drift.</li> <li>[ ] Docs are self-contained (no cross-repo references).</li> <li>[ ] Experimental surfaces (ND/ANN) labeled consistently across README, spec, and API.</li> <li>[ ] Changelog reflects current release and states \u201cfirst public release\u201d history squash.</li> <li>[ ] Release checklist items that touch docs are complete (<code>docs/maintainer/release_checklist.md</code>).</li> <li>[ ] Documentation debt log (<code>docs/maintainer/debt_log.md</code>) reviewed and none of the items block freeze.</li> <li>[ ] Root docs (README, docs/index.md, start_here) are frozen; any change after freeze requires compatibility justification in <code>docs/maintainer/compatibility_breaks.md</code>.</li> </ul>"},{"location":"maintainer/extension_points/","title":"Extension points (public seams)","text":"<p>Allowed:</p> <ul> <li>New adapters implementing <code>contracts.resources.VectorSource</code>/<code>ExecutionLedger</code> respecting ExecutionContract capabilities.</li> <li>New ANN runners subclassing <code>AnnExecutionRequestRunner</code> that declare randomness sources, bounds, and deterministic fallback policy.</li> <li>New execution algorithms registered via <code>domain.execution_algorithms.base.register_algorithm</code> that respect contract compatibility.</li> <li>Plugins discovered via entrypoints: <code>bijux_vex.vectorstores</code>, <code>bijux_vex.embeddings</code>, <code>bijux_vex.runners</code>.</li> </ul> <p>Forbidden:</p> <ul> <li>Injecting execution logic into services or boundaries layers.</li> <li>Extending public API without corresponding spec coverage and invariant IDs.</li> <li>Mutating provenance or ledger entries post-commit.</li> </ul> <p>Warnings (will break determinism if abused):</p> <ul> <li>Randomness sources not surfaced in <code>DeterminismReport</code>.</li> <li>Adapters claiming deterministic support while using approximate paths.</li> <li>Bypassing <code>ExecutionSession</code>/<code>ExecutionPlan</code> when executing.</li> </ul>"},{"location":"maintainer/extension_policy/","title":"Extension acceptance policy","text":"<p>Welcome:</p> <ul> <li>New backends/adapters that honor contracts and invariants.</li> <li>New comparison policies or audit/reporting extensions.</li> <li>Additional examples, docs, or tooling that reinforce contracts.</li> </ul> <p>Not welcome:</p> <ul> <li>Extensions that bypass contracts (silent fallback, hidden randomness).</li> <li>New public entrypoints that duplicate existing verbs (<code>execute</code>, <code>replay</code>, <code>compare</code>, <code>explain</code>).</li> <li>Mutations during replay or compare paths.</li> </ul> <p>Rules:</p> <ul> <li>Public API modules are fixed; extend via documented seams (adapters, policies), not by adding new surfaces.</li> <li>Any extension must document its invariants and add tests that enforce them.</li> </ul>"},{"location":"maintainer/freeze_criteria/","title":"Freeze criteria (v0.1.0)","text":"<p>Freeze is allowed only when all gates are satisfied:</p> <ul> <li>Core decomposition in place (contracts/runtime/policies/types/identity) with no file &gt;300 LOC doing mixed responsibilities.</li> <li>Services contain glue only; decision logic delegated to commands/domain.</li> <li>Test tree mirrors src tree 1:1.</li> <li>Adversarial execution scenarios pass (drift-within-bounds, corruption replay refusal, budget exhaustion).</li> <li>Failure semantics and invariants documented and enforced by tests.</li> <li>No TODO/FIXME in <code>src/bijux_vex/core</code>.</li> <li>Docs: mental_model, failure_semantics, vdb_profile present and linked in doc map.</li> <li>All gates: <code>make test lint quality security</code> green.</li> <li>Exclusions honored: <code>pgvector_backend</code> remains excluded (see <code>core/v1_exclusions.py</code>).</li> <li>Deterministic execution surface and ABI are frozen; breaking deterministic changes require a major version bump.</li> <li>Non-deterministic/ANN execution is experimental and may change; users must treat ND behavior as unstable.</li> <li>Posture: bijux-vex is contract-complete and open to empirical refinement; feature changes must be framed as contract extensions and approved through freeze governance.</li> </ul> <p>Kill-switch: if any criterion fails, release tagging is blocked and freeze is revoked.</p>"},{"location":"maintainer/if_i_disappear/","title":"If I disappear","text":"<ul> <li>Releases: run <code>make lint quality security test docs api</code> then <code>make release</code>; tags drive versions (hatch-vcs).</li> <li>Must never change: deterministic execution semantics/ABI, public API modules, error taxonomy for deterministic paths.</li> <li>Say \u201cno\u201d to PRs that: bypass contracts, add DB-like semantics, or weaken invariants.</li> <li>Docs/tests are gates: mkdocs strict, api-freeze, conformance suites must stay green.</li> <li>Contact/review: treat ND/ANN changes as experimental; require contract/test updates.</li> </ul>"},{"location":"maintainer/maintenance_mode_criteria/","title":"Maintenance-mode criteria (future)","text":"<p>Do not declare maintenance-only until:</p> <ul> <li>at least one stable public release cycle (v0.1.x \u2192 v0.2.x) with migration experience.</li> <li>documented external adopters and integrations.</li> <li>no pending contract changes or experimental ND features.</li> <li>governance decision recorded in design_diary and freeze_criteria.</li> </ul> <p>Until then: bijux-vex is contract-complete and open to empirical refinement.</p>"},{"location":"maintainer/makefile_contract/","title":"Makefile contract","text":"<p>The Makefile targets are part of the public tooling surface. Changes require justification in <code>docs/maintainer/compatibility_breaks.md</code>.</p> <p>Stable targets (treated as contracts):</p> <ul> <li><code>install</code>, <code>bootstrap</code></li> <li><code>fmt</code>, <code>lint</code>, <code>test</code>, <code>quality</code>, <code>security</code>, <code>docs</code>, <code>api</code>, <code>hygiene</code>, <code>sbom</code></li> <li><code>all</code>, <code>clean</code>, <code>clean-soft</code></li> <li><code>release</code></li> </ul> <p>Reserved/UX-parity targets:</p> <ul> <li><code>build</code>: intentionally fails with guidance to use <code>make release</code>.</li> <li><code>citation</code>: intentionally fails until citation metadata is published.</li> </ul> <p>Any new target added for CI or user workflows must be documented here before release.</p>"},{"location":"maintainer/pre_release_self_audit/","title":"Pre\u2011Release Self\u2011Audit","text":"<p>Run these before tagging a release:</p> <ul> <li><code>make lint quality security test docs api</code></li> <li><code>bijux vex doctor</code></li> <li><code>bijux vex bench --mode exact --store memory --repeats 1</code></li> <li>Inspect one deterministic provenance artifact</li> <li>Inspect one ND provenance artifact</li> </ul>"},{"location":"maintainer/release_checklist/","title":"Release checklist (v0.1.x)","text":"<ul> <li>[ ] Working tree clean; no untracked artifacts.</li> <li>[ ] <code>make lint quality security test</code> passes with zero warnings.</li> <li>[ ] <code>make docs</code> (mkdocs build --strict) passes; no navigation warnings.</li> <li>[ ] <code>docs/maintainer/docs_freeze_checklist.md</code> reviewed and satisfied.</li> <li>[ ] <code>api/v1/schema.yaml</code> committed; <code>make api-freeze</code> passes (no drift).</li> <li>[ ] OpenAPI validation tests green; schema reachable in docs.</li> <li>[ ] README badges and docs links verified.</li> <li>[ ] CHANGELOG updated via towncrier; v0.1.0 section accurate.</li> <li>[ ] Release artifacts built (<code>make release</code>): wheel/sdist, SBOM, refreshed OpenAPI.</li> <li>[ ] Tags signed: <code>git tag -s v0.1.x</code>.</li> <li>[ ] CI workflows (ci.yml, release.yml) green on tag.</li> </ul>"},{"location":"maintainer/release_dry_run/","title":"Release dry-run checklist","text":"<p>Use this before tagging to avoid publishing broken artifacts.</p> <ul> <li>Clean tree; <code>make lint quality security api test</code> green.</li> <li><code>make api</code> regenerates schema with no drift.</li> <li>Build wheel locally: <code>python -m build</code> (or <code>make release</code> if enabled).</li> <li>Install wheel in a fresh venv, run <code>bijux vex --help</code>, and execute a deterministic flow end-to-end.</li> <li><code>mkdocs build --strict</code> succeeds (docs reachable, no warnings).</li> <li>SBOM generated (<code>make sbom</code>) with zero unignored vulns.</li> <li>Confirm README badges and links resolve.</li> </ul>"},{"location":"maintainer/release_process/","title":"Release process (bijux-vex v0.1.x)","text":""},{"location":"maintainer/release_process/#preconditions","title":"Preconditions","text":"<ul> <li>Working tree clean; <code>git status</code> empty.</li> <li>All gates green: <code>make lint quality security test</code>.</li> <li>Public API surface and OpenAPI freeze tests passing.</li> <li>Execution ABI fingerprint unchanged or intentionally bumped with doc updates.</li> </ul>"},{"location":"maintainer/release_process/#versioning-and-tagging","title":"Versioning and tagging","text":"<ul> <li>Version derives from git tags via <code>hatch-vcs</code>; do not edit <code>pyproject.toml</code> for version bumps.</li> <li>Tag format: <code>v0.1.0</code>, <code>v0.1.0-rc1</code>, etc.</li> <li>Dirty worktree produces a <code>.dirty</code> local version; do not publish in that state.</li> </ul>"},{"location":"maintainer/release_process/#release-steps","title":"Release steps","text":"<p>1) <code>make lint quality security test</code> 2) <code>make docs</code> (mkdocs build --strict) 3) <code>make api-freeze</code> (ensures schema.yaml \u2192 openapi.v1.json drift-free) 4) <code>make release</code> (builds wheel+sdist, SBOM, refreshes OpenAPI) 5) Update CHANGELOG via towncrier if needed. 6) Confirm <code>docs/maintainer/release_checklist.md</code> is complete. 7) Create signed tag <code>git tag -s v0.1.0 -m \"v0.1.0\"</code> 8) Push tag: <code>git push origin v0.1.0</code></p>"},{"location":"maintainer/release_process/#github-automation-expectations","title":"GitHub automation expectations","text":"<ul> <li>CI workflow must run tests, lint, quality, security on PRs and tags.</li> <li>Release workflow should build wheel/sdist, attach SBOM, and upload artifacts to the GitHub release page.</li> <li>Tag protection: only signed, CI-green tags are published.</li> </ul>"},{"location":"maintainer/release_process/#post-release","title":"Post-release","text":"<ul> <li>Update docs/README if behavior changed.</li> <li>If ABI or public surface shifts, bump PUBLIC API or ABI versions and document rationale.</li> </ul>"},{"location":"maintainer/security_model/","title":"Security &amp; abuse model","text":"<p>In scope:</p> <ul> <li>Replay poisoning: mitigated via provenance hashes and immutable artifacts.</li> <li>Artifact spoofing: mitigated via fingerprint checks and audit chain.</li> <li>Capability refusal: ND without ANN results in <code>NDExecutionUnavailableError</code>.</li> <li>Authz denial: mutations blocked via <code>Authz</code> contracts.</li> </ul> <p>Out of scope:</p> <ul> <li>Multi-tenant isolation guarantees.</li> <li>Network-level ACLs beyond Authz hooks.</li> <li>Side-channel attacks or timing analysis.</li> </ul> <p>Operator guidance:</p> <ul> <li>Treat provenance ledger as tamper-evident; rotate or archive per retention policy.</li> <li>Run divergence detection to catch backend drift.</li> <li>Do not bypass invariants via retry wrappers.</li> <li>Vulnerability posture: <code>py==1.11.0</code> triggers PYSEC-2022-42969 with no upstream fix yet. SBOM generation ignores this ID explicitly until a patched release is available; upgrade once released.</li> </ul>"},{"location":"maintainer/testing_policy/","title":"Testing policy (frozen)","text":"<ul> <li>tox runs the full test matrix across supported Python versions.</li> <li>Lint, quality, security, typing gates run once on the oldest supported Python (3.11) to control CI time/cost; this is intentional.</li> <li>pytype is skipped (Python version churn + maintenance cost); do not re-enable without explicit approval. If installed, it is advisory only.</li> <li>Contributors must not \u201coptimize\u201d gates to run on all versions; matrix belongs in tox only.</li> </ul>"},{"location":"maintainer/v0_2_0_progress_checklist/","title":"v0.2.0 Progress Checklist","text":"<p>This checklist maps tasks to phases. It is the release gate for v0.2.0.</p>"},{"location":"maintainer/v0_2_0_progress_checklist/#phase-a-contract-compatibility-guardrails","title":"Phase A \u2014 Contract &amp; Compatibility Guardrails","text":"<ul> <li>[ ] Backward compatibility contract doc</li> <li>[ ] Golden v0.1 replay test</li> <li>[ ] CLI flags snapshot test</li> <li>[ ] Implicitness contract doc</li> <li>[ ] Capabilities report command</li> </ul>"},{"location":"maintainer/v0_2_0_progress_checklist/#phase-b-vector-db-architecture-design-first","title":"Phase B \u2014 Vector DB Architecture (Design First)","text":"<ul> <li>[ ] VectorStoreAdapter interface (code + doc)</li> <li>[ ] Explicit opt-in flag design doc</li> <li>[ ] Determinism matrix (storage \u00d7 execution)</li> <li>[ ] Failure semantics spec updates</li> <li>[ ] Architecture diagram update</li> </ul>"},{"location":"maintainer/v0_2_0_progress_checklist/#phase-c-embeddings-ann-guardrails","title":"Phase C \u2014 Embeddings &amp; ANN Guardrails","text":"<ul> <li>[ ] Embedding generation contract doc</li> <li>[ ] Provenance schema extension</li> <li>[ ] ANN graduation criteria</li> <li>[ ] ANN runner audit doc</li> <li>[ ] Performance baseline harness + stored results</li> </ul>"},{"location":"maintainer/v0_2_0_progress_checklist/#phase-d-docs-ux-trust","title":"Phase D \u2014 Docs, UX, Trust","text":"<ul> <li>[ ] README \u2194 docs drift fixed</li> <li>[ ] \u201cNot a Vector DB\u201d section rewritten</li> <li>[ ] Start Here path added</li> <li>[ ] Experimental labels everywhere</li> <li>[ ] v0.2.0 checklist published</li> </ul>"},{"location":"maintainer/why_this_is_hard/","title":"Why this is hard","text":"<ul> <li>Vector execution is harder than storage: algorithms, randomness, and approximation choices happen at runtime, not at ingest.</li> <li>ANN breaks na\u00efve determinism: traversal order, pruning, and sampling introduce entropy that must be declared and bounded.</li> <li>Replay is non-trivial: deterministic replay demands bit-stability; ND replay demands statistical envelopes and provenance strong enough to prove consistency.</li> <li>Backend drift is silent: without comparison and divergence detection, approximate systems rot unnoticed.</li> <li>Budgets are hard constraints: latency/memory/probe limits must halt execution, not merely warn.</li> </ul>"},{"location":"maintainer/rationale/anti_goals/","title":"bijux-vex anti-goals","text":"<ul> <li>Not a vector database or key-value store.</li> <li>Not an embedding or model inference framework.</li> <li>Not a RAG orchestration system.</li> <li>Not a generic serving layer or SLA manager.</li> <li>Not a benchmark suite; comparisons exist to validate contracts, not to market performance.</li> </ul> <p>Every new feature must demonstrate how it strengthens vector execution contracts or auditability. If it drifts toward these anti-goals, it should be rejected.</p>"},{"location":"maintainer/rationale/philosophy/","title":"bijux-vex philosophy","text":"<ul> <li>bijux-vex is a vector execution engine, not a database.</li> <li>Contracts (deterministic vs non-deterministic) are first-class and enforced.</li> <li>Execution artifacts are replayable evidence, not storage indexes.</li> <li>Approximation is explicit, auditable, and comparable against exact runs.</li> <li>Backends are interchangeable execution substrates that must declare capabilities and refuse incompatible contracts.</li> </ul>"},{"location":"overview/architecture_overview/","title":"Architecture Overview","text":"<pre><code>request \u2192 plan \u2192 execute \u2192 provenance\n            \u251c\u2500 deterministic (exact)\n            \u2514\u2500 ND (ANN) + quality\nvector store: optional + explicit\n</code></pre>"},{"location":"overview/architecture_walkthrough/","title":"Architecture Diagram &amp; Walkthrough","text":""},{"location":"overview/architecture_walkthrough/#high-level-diagram","title":"High-level diagram","text":"<pre><code>request\n  \u2514\u2500&gt; plan\n        \u251c\u2500 deterministic path\n        \u2502    \u251c\u2500 exact execution\n        \u2502    \u2514\u2500 provenance\n        \u2514\u2500 ND path\n             \u251c\u2500 runner selection\n             \u251c\u2500 ANN execution\n             \u251c\u2500 witness / quality metrics\n             \u2514\u2500 provenance\n\nstorage &amp; adapters\n  \u251c\u2500 memory / sqlite\n  \u251c\u2500 faiss\n  \u2514\u2500 qdrant\n\nembeddings\n  \u251c\u2500 explicit provider\n  \u2514\u2500 explicit cache\n</code></pre>"},{"location":"overview/architecture_walkthrough/#walkthrough","title":"Walkthrough","text":"<ol> <li> <p>Request A CLI or API request is validated and normalized. All implicit behavior is refused. Optional components must be explicitly declared.</p> </li> <li> <p>Plan The system produces an execution plan that captures mode (deterministic or ND), budgets, runner selection, and adapter configuration.</p> </li> <li> <p>Execution</p> </li> <li>Deterministic path uses exact search and rejects any non-deterministic component.</li> <li> <p>ND path selects a runner, executes ANN, and may perform witness verification or quality measurement.</p> </li> <li> <p>Postprocess Results are ordered by a canonical contract. ND postprocess may re-rank or refuse based on quality policy.</p> </li> <li> <p>Provenance Every execution emits a provenance artifact describing inputs, decisions, randomness, and bounds. This is the basis for replay and audit.</p> </li> </ol> <p>This model ensures users always understand what happened, why it happened, and what the system refused to do.</p>"},{"location":"overview/concepts/","title":"Conceptual overview","text":"<p>This page is descriptive, not normative. It explains bijux-vex in plain language without APIs or enums.</p>"},{"location":"overview/concepts/#what-bijux-vex-is","title":"What bijux-vex is","text":"<ul> <li>A vector execution engine: it runs vector similarity computations under explicit contracts.</li> <li>Contracts come in two flavors:</li> <li>Deterministic: exact algorithms, replayable outputs, bit-stable provenance.</li> <li>Non-deterministic (experimental): ANN/approximate algorithms, bounded divergence, declared randomness.</li> <li>Every run is tied to an execution plan, provenance, and artifacts that record how results were produced.</li> </ul>"},{"location":"overview/concepts/#vector-execution-vs-vector-db","title":"Vector execution vs. vector DB","text":"<ul> <li>Vector DBs focus on storage and serving; execution is implicit and often approximate by default.</li> <li>bijux-vex focuses on execution semantics: what was run, under which guarantees, and how to replay or compare results.</li> <li>Artifacts, plans, and provenance are first-class; storage backends are just sources and ledgers.</li> </ul>"},{"location":"overview/concepts/#core-objects-conceptual","title":"Core objects (conceptual)","text":"<ul> <li>Execution plan: the declared algorithm, contract, and parameters.</li> <li>Execution artifact: the outputs plus provenance and signatures.</li> <li>Provenance: the audit trail that explains how the artifact was produced.</li> <li>Randomness profile: where nondeterminism enters and how it is bounded.</li> </ul>"},{"location":"overview/concepts/#how-determinism-works-here","title":"How determinism works here","text":"<ul> <li>Deterministic runs use exact search and must replay identically.</li> <li>Non-deterministic runs must emit approximation reports and randomness metadata; replay checks envelopes, not equality.</li> </ul>"},{"location":"overview/concepts/#how-to-approach-the-docs","title":"How to approach the docs","text":"<ul> <li>If you want rules: go to <code>spec/system_contract.md</code> and <code>spec/execution_contracts.md</code>.</li> <li>If you want rationale: see <code>design/why_vector_execution.md</code> and <code>design/contracts.md</code>.</li> <li>If you want to run something: start with <code>examples/overview.md</code>.</li> </ul>"},{"location":"spec/ann_graduation_criteria/","title":"ANN Graduation Criteria (experimental \u2192 stable)","text":"<p>ANN remains experimental until all criteria below are met and recorded.</p>"},{"location":"spec/ann_graduation_criteria/#criteria","title":"Criteria","text":"<ul> <li>Determinism envelope: replay divergence stays within declared bounds across repeated runs.</li> <li>Audit completeness: approximation reports include algorithm/version, params, and randomness sources.</li> <li>Budget compliance: ANN budget enforcement is deterministic and test-covered.</li> <li>Cross-backend consistency: at least one cross-backend replay/compare test passes for ANN.</li> <li>Performance baseline: benchmark harness exists and regressions are measurable.</li> <li>Failure semantics: ANN failures produce explicit errors; no silent fallback.</li> </ul>"},{"location":"spec/ann_graduation_criteria/#graduation-checklist","title":"Graduation checklist","text":"<ul> <li>All criteria above satisfied and documented.</li> <li>ANN status flipped to <code>stable</code> in capabilities output.</li> <li>Documentation updated to remove \u201cexperimental\u201d labels.</li> </ul> <p>Until then, ANN output must be labeled experimental in CLI/API/provenance.</p>"},{"location":"spec/architecture_diagram/","title":"Architecture diagram (single source)","text":"<p>Textual diagram:</p> <p><code>CLI/API \u2192 Orchestrator (glue only) \u2192 ExecutionSession (state machine) \u2192 ExecutionPlan (immutable) \u2192 Algorithm (exact/approx mode)</code></p> <p><code>Algorithm \u2192 Adapters (VectorSource, ExecutionLedger, ANN runner, optional VectorStoreAdapter) \u2192 ExecutionResult + Provenance \u2192 Ledger</code></p> <p><code>Optional VectorStoreAdapter \u2192 External VDB (explicit opt-in)</code></p> <p>Contracts/invariants hit:</p> <ul> <li>Contract alignment (INV-010) at session start</li> <li>Randomness/budget required for ND (INV-020) in planning</li> <li>Plan immutability/fingerprint in ExecutionPlan</li> <li>Determinism enforcement pre-algorithm selection</li> <li>Provenance requirement on replay (INV-040)</li> <li>Ledger integrity on persist/replay</li> </ul> <p>Trust boundaries:</p> <ul> <li>CLI/API input is untrusted; validation happens at the boundary.</li> <li>Adapter boundary is a trust boundary; external VDBs are not trusted by default.</li> <li>Optional VDB usage requires explicit opt-in and must not silently fall back.</li> </ul>"},{"location":"spec/determinism_matrix/","title":"Determinism Matrix (Storage \u00d7 Execution)","text":"<p>This matrix is normative. It defines determinism, auditability, and experimental status for each storage/execution combination.</p> Storage Execution Deterministic? Auditable? Experimental? Notes Memory Exact Yes Yes No Fully deterministic; replay must match bit-for-bit. Memory ANN No (bounded) Yes Yes Requires randomness profile + budgets; replay is envelope-based. VDB (FAISS local) Exact Yes Yes Yes IndexFlatL2 is deterministic; explicit opt-in required. VDB (FAISS local) ANN No (bounded) Only if adapter proves it Yes ANN not implemented in v0.2. VDB (external) Exact No by default Only if adapter proves it Yes (future) Requires explicit opt-in + adapter contract. VDB (external) ANN No (bounded) Only if adapter proves it Yes (future) Explicit opt-in required."},{"location":"spec/determinism_matrix/#determinism-rules","title":"Determinism rules","text":"<ul> <li>\u201cDeterministic\u201d means bit-identical replay under the same contract.</li> <li>\u201cAuditable\u201d means provenance is emitted and replay/compare are legal under declared bounds.</li> <li>Any VDB path is non-default and must be explicitly selected.</li> </ul>"},{"location":"spec/doc_to_code_map/","title":"Doc to code map","text":"<ul> <li>docs/spec/read_this_first.md \u2192 src/bijux_vex/core</li> <li>docs/spec/execution_contracts.md \u2192 src/bijux_vex/core/contracts, src/bijux_vex/domain/execution_requests</li> <li>docs/spec/failure_semantics.md \u2192 src/bijux_vex/core/errors, src/bijux_vex/core/failures.py</li> <li>docs/spec/execution_lifecycle.md \u2192 src/bijux_vex/core/runtime, src/bijux_vex/domain/execution_requests</li> <li>docs/spec/execution_artifacts.md \u2192 src/bijux_vex/domain/execution_artifacts</li> <li>docs/spec/examples \u2192 tests/e2e</li> <li>docs/spec/system_contract.md \u2192 src/bijux_vex</li> <li>docs/spec/invariant_ids.md \u2192 src/bijux_vex/core/errors/error_types.py</li> <li>docs/maintainer/why_this_is_hard.md \u2192 docs/maintainer</li> <li>docs/spec/mental_model.md \u2192 src/bijux_vex/core</li> <li>docs/spec/vdb_profile.md \u2192 src/bijux_vex</li> <li>docs/maintainer/freeze_criteria.md \u2192 docs/maintainer</li> <li>docs/spec/identity.md \u2192 src/bijux_vex</li> <li>docs/user/not_a_vdb.md \u2192 docs/user</li> <li>docs/maintainer/extension_points.md \u2192 src/bijux_vex</li> </ul>"},{"location":"spec/embeddings_contract/","title":"Embedding Generation Contract","text":"<p>Embedding generation is a contracted step, not a hidden side-effect. It may be deterministic or non-deterministic, but it must always surface provenance.</p>"},{"location":"spec/embeddings_contract/#rules","title":"Rules","text":"<ul> <li>Embedding generation must be explicitly invoked; no implicit embedding creation.</li> <li>Deterministic embeddings must be reproducible under a declared model/version.</li> <li>Non-deterministic embeddings must declare randomness sources and bounds.</li> <li>If vectors are omitted, <code>--embed-model</code> (or API <code>embed_model</code>) is required.</li> <li>The default local provider is <code>sentence_transformers</code> (optional extra).</li> <li>Embedding caching is opt-in only (<code>--cache-embeddings</code>); no implicit cache.</li> </ul>"},{"location":"spec/embeddings_contract/#provenance-requirements","title":"Provenance requirements","text":"<p>Every embedding step must emit the following metadata (see provenance schema extension):</p> <ul> <li><code>embedding_source</code></li> <li><code>embedding_determinism</code></li> <li><code>embedding_seed</code></li> <li><code>embedding_model_version</code></li> <li><code>embedding_provider</code></li> <li><code>embedding_device</code></li> <li><code>embedding_dtype</code></li> </ul>"},{"location":"spec/embeddings_contract/#status","title":"Status","text":"<p>Embedding generation is available via the local sentence-transformers provider when explicitly enabled.</p>"},{"location":"spec/execution_artifacts/","title":"Execution artifacts","text":"<p>An execution artifact records what ran and how:</p> <ul> <li>links to corpus + vector fingerprints</li> <li>execution contract and plan fingerprint</li> <li>randomness audit (sources, budget)</li> <li>approximation + determinism reports</li> <li>execution signature tying all of the above</li> </ul> <p>Portability guarantees:</p> <ul> <li>Artifacts are versioned; compatibility is enforced by the execution ABI.</li> <li>Replay does not require live vector sources; artifacts plus plan are sufficient.</li> <li>Backends must refuse execution if they cannot meet the artifact\u2019s contract/metric.</li> </ul> <p>Mutation rules:</p> <ul> <li>Artifacts are immutable once committed.</li> <li>Ledger retention may prune historical results but preserves chain hash integrity.</li> </ul> <p>Docs \u2192 code</p> <ul> <li><code>src/bijux_vex/core/execution_result.py</code></li> <li><code>src/bijux_vex/core/abi/__init__.py</code></li> <li><code>src/bijux_vex/domain/execution_artifacts/</code></li> </ul>"},{"location":"spec/execution_contracts/","title":"Execution contracts","text":""},{"location":"spec/execution_contracts/#deterministic-execution","title":"Deterministic execution","text":"<ul> <li>MUST guarantee bit-stable results.</li> <li>MUST NOT include hidden randomness or approximate paths.</li> <li>Replay MUST match exactly; any divergence is an invariant failure.</li> <li>Backends MUST declare <code>deterministic_query=True</code> and MUST refuse if they cannot meet it.</li> </ul>"},{"location":"spec/execution_contracts/#non-deterministic-execution","title":"Non-deterministic execution","text":"<ul> <li>Contract is stable; behavior remains experimental until ANN graduation criteria are met.</li> <li>REQUIRES:</li> <li><code>RandomnessProfile</code> (seed, sources, boundedness, budget)</li> <li><code>DeterminismReport</code> persisted with every result</li> <li><code>ApproximationReport</code> (recall, rank displacement, distance error, algorithm, backend, randomness sources, fallback flag)</li> <li>Replay MUST compare within declared bounds (distribution-consistent), not equality.</li> <li>See <code>docs/spec/non_deterministic_execution.md</code> for the full semantics.</li> </ul>"},{"location":"spec/execution_contracts/#allowed-sources-of-nondeterminism","title":"Allowed sources of nondeterminism","text":"<ul> <li>Graph traversal order.</li> <li>Sampling/beam heuristics.</li> <li>Parallelism-induced ordering changes. All MUST be named in the plan via <code>RandomnessSource</code>.</li> </ul>"},{"location":"spec/execution_contracts/#comparison-semantics","title":"Comparison semantics","text":"<ul> <li>Exact vs approximate comparisons MUST measure recall@k, rank instability, overlap ratio.</li> <li>Policies MAY gate approximate runs: minimum recall, maximum instability.</li> </ul>"},{"location":"spec/execution_contracts/#versioning-rationale","title":"Versioning rationale","text":"<ul> <li>ABI versioning exists to keep deterministic replay stable across refactors.</li> <li>Canon versioning exists to keep fingerprints and hashing rules stable for provenance chains.</li> <li>Schema versioning (API/OpenAPI) exists to keep external integrations honest; breaking changes require a new major API version.</li> </ul>"},{"location":"spec/execution_contracts/#doc-code-map","title":"Doc \u2192 code map","text":"<ul> <li>Contracts: <code>src/bijux_vex/core/contracts/__init__.py</code></li> <li>Randomness profile: <code>src/bijux_vex/core/vector_execution.py</code></li> <li>Reports: <code>src/bijux_vex/core/execution_result.py</code></li> <li>Enforcement: <code>src/bijux_vex/domain/execution_requests/execute.py</code>, <code>plan.py</code></li> </ul>"},{"location":"spec/execution_intent_matrix/","title":"Execution intent contract matrix","text":"intent allowed contracts allowed modes EXACT_VALIDATION deterministic strict REPRODUCIBLE_RESEARCH deterministic, non_deterministic strict (DET), bounded/ exploratory (ND) EXPLORATORY_SEARCH non_deterministic bounded, exploratory PRODUCTION_RETRIEVAL deterministic strict <p>Rules:</p> <ul> <li>Intent is always explicit and coerced to <code>ExecutionIntent</code> at boundary ingress.</li> <li>Non-deterministic intents require an execution budget and randomness profile.</li> <li>Deterministic intents must use strict mode; ND intents must not use strict mode.</li> </ul>"},{"location":"spec/execution_lifecycle/","title":"Execution lifecycle (canonical)","text":"<p>Flow (text diagram): <code>ExecutionSession.start</code> \u2192 <code>ExecutionPlan.build</code> \u2192 <code>execute_request</code> \u2192 <code>postprocess</code> \u2192 <code>ledger.persist</code> \u2192 <code>replay|compare</code></p> <p>Where invariants fire:</p> <ul> <li>Session start: contract alignment, capability checks (INV-010, capability invariants).</li> <li>Planning: randomness required for ND (INV-020), ABI compatibility.</li> <li>Execute: budget enforcement, ANN refusal for deterministic.</li> <li>Postprocess: determinism/approximation reports attached.</li> <li>Ledger persist: artifact/signature immutability.</li> <li>Replay: provenance required (INV-040); deterministic equality vs ND envelope.</li> </ul> <p>Determinism enforcement:</p> <ul> <li>Contract split before algorithm selection.</li> <li>ND requires randomness profile + budget; deterministic forbids ANN paths.</li> <li>Replay checks <code>results_fingerprint</code> (deterministic) or divergence envelope (ND).</li> </ul> <p>Artifacts and provenance:</p> <ul> <li>ExecutionResult stores plan, cost, approximation, determinism report, fingerprints.</li> <li>ExecutionArtifact ties corpus/vector fingerprints to execution signature.</li> <li>Ledger retention may compact but must preserve chain hashes.</li> </ul> <p>Docs \u2192 code</p> <ul> <li><code>src/bijux_vex/core/runtime/execution_plan.py</code></li> <li><code>src/bijux_vex/core/runtime/execution_session.py</code></li> <li><code>src/bijux_vex/domain/execution_requests/plan.py</code></li> <li><code>src/bijux_vex/domain/execution_requests/execute.py</code></li> <li><code>src/bijux_vex/domain/provenance/replay.py</code></li> </ul>"},{"location":"spec/failure_semantics/","title":"Failure semantics","text":"<ul> <li>InvariantError: terminal, never retryable; indicates contract or state violation.</li> <li>BudgetExceededError: execution stops, may return partial results; classified as retryable only if budgets are adjusted.</li> <li>BackendDivergenceError: indicates drift between backends; requires operator action, not blind retry.</li> <li>ValidationError / ConflictError / NotFoundError: client or request issues; retries without change are meaningless.</li> <li>AtomicityViolationError: transactional misuse; must be fixed in code/tests.</li> <li>NDExecutionUnavailableError: non-deterministic execution requested without ANN support; allowed failure mode, caller must select a deterministic contract or provide ANN backend.</li> <li>BackendCapabilityError: requested capability (e.g., external vector store) not available; no silent fallback.</li> <li>AnnIndexBuildError / AnnQueryError / AnnBudgetError: ANN backend failures are terminal for the request; no silent fallback to exact execution.</li> </ul> <p>Classification lives in <code>FailureKind</code> and <code>FAILURE_ACTIONS</code>:</p> <ul> <li>retryable: transient backend or IO failures (not invariants).</li> <li>terminal: invariants, ABI mismatches, capability refusals.</li> <li>alert/escalate: backend divergence, provenance corruption.</li> </ul>"},{"location":"spec/failure_semantics/#error-semantics-table","title":"Error semantics table","text":"Error type Retryable User-visible Provenance impact Deterministic outcome <code>InvariantError</code> No Yes Recorded as terminal failure Execution aborted <code>ValidationError</code> No Yes Recorded N/A <code>BudgetExceededError</code> No (partial) Yes Partial results stored; status PARTIAL Deterministic: mismatch; ND: allowed with divergence recorded <code>BackendDivergenceError</code> No Yes Stored with divergence detail Deterministic: failure; ND: allowed with bounds <code>ReplayNotSupportedError</code> No Yes No new provenance N/A <code>AuthzDeniedError</code> No Yes No execution recorded N/A <code>NotFoundError</code> No Yes No execution recorded N/A <code>NDExecutionUnavailableError</code> No Yes Recorded with capability refusal N/A <code>BackendCapabilityError</code> No Yes Recorded with capability refusal N/A <code>AnnIndexBuildError</code> No Yes Recorded with ANN failure detail N/A <code>AnnQueryError</code> No Yes Recorded with ANN failure detail N/A <code>AnnBudgetError</code> No Yes Recorded with ANN budget detail N/A Stable public errors <code>ValidationError</code>, <code>InvariantError</code>, <code>ConflictError</code>, <code>NotFoundError</code>, <code>AuthzDeniedError</code>, <code>BackendDivergenceError</code>, <code>BackendCapabilityError</code>, <code>ReplayNotSupportedError</code>, <code>BudgetExceededError</code>, <code>AnnIndexBuildError</code>, <code>AnnQueryError</code>, <code>AnnBudgetError</code>, <code>NDExecutionUnavailableError</code> <p>Docs \u2192 code</p> <ul> <li><code>src/bijux_vex/core/errors/error_types.py</code></li> <li><code>src/bijux_vex/core/failures.py</code></li> <li><code>src/bijux_vex/domain/provenance/replay.py</code></li> </ul>"},{"location":"spec/identity/","title":"bijux-vex identity (freeze-bound)","text":"<ul> <li>bijux-vex is a vector execution engine with explicit contracts for determinism, nondeterminism, and replay.</li> <li>bijux-vex is not a vector database, embedding service, or retrieval framework. It records execution consequences; it does not offer serving SLAs.</li> <li>bijux-vex solves the problem of running and comparing deterministic vs approximate vector executions with auditable provenance. Reasoning execution is intentionally out of scope; bijux-vex is the vector execution engine.</li> <li>Use bijux-vex when you need: replayable vector experiments, explicit nondeterministic bounds, cross-backend drift detection, and compliance gates on approximation.</li> <li>Do not use bijux-vex when you need: low-latency serving, multi-tenant storage, model hosting, or generic RAG pipelines. Use a vector DB + discipline instead.</li> <li>Contract: every execution requires an execution contract, intent, budget, and session; provenance is mandatory for replay. If these feel heavy, bijux-vex is the wrong tool.</li> <li>Thesis: bijux-vex makes deterministic and approximate vector execution comparable, auditable, and replayable as contracts. Existing vector stores cannot enforce or explain determinism/approximation gaps at this level.</li> </ul>"},{"location":"spec/invariant_ids/","title":"Invariant IDs","text":"<p>Every invariant failure MUST emit an ID. Defaults use <code>INV-000</code> but should be replaced with specific IDs over time.</p> <ul> <li>INV-000: unspecified invariant violation (temporary default)</li> <li>INV-010: execution contract mismatch</li> <li>INV-011: backend capability refusal</li> <li>INV-020: missing randomness for ND execution</li> <li>INV-021: budget exhaustion triggered</li> <li>INV-030: plan fingerprint mismatch</li> <li>INV-040: deterministic replay divergence</li> </ul> <p>Each ID MUST appear in exception text and MUST be covered by at least one test.</p>"},{"location":"spec/invariants_overview/","title":"Invariants overview (one page)","text":"<pre><code>Request\n  | (contract + intent + budget validated)\n  v\nSession\n  | (state machine; randomness + resources bound)\n  v\nPlan (fingerprinted)\n  | (immutability enforced; capabilities checked)\n  v\nExecution\n  | (algorithm + contract + randomness applied)\n  v\nResult + Provenance\n  | (approximation + determinism reports; audit chain)\n  v\nReplay/Compare\n  | (deterministic \u21d2 equality; ND \u21d2 envelope)\n</code></pre> <p>Invariants fire at every arrow:</p> <ul> <li>Contract/intent/budget required.</li> <li>Session transitions guarded.</li> <li>Plan fingerprint verified before execution.</li> <li>ND requires randomness profile and approximation report; deterministic forbids randomness.</li> <li>Provenance is mandatory; replay refuses without it.</li> </ul>"},{"location":"spec/irreducible_core/","title":"Irreducible core (must survive any refactor)","text":"<p>Non-negotiable invariants: 1) Contract alignment (INV-010): artifact and request execution_contract must match; enforced in planning and replay. 2) Determinism declaration (INV-020): ND execution requires explicit randomness + budget; deterministic path forbids ANN. 3) Provenance requirement (INV-040): replay only legal with stored execution result and matching contract/ABI. 4) Plan immutability: ExecutionPlan fingerprint ties algorithm+contract+k+randomness; mutation invalidates execution. 5) Ledger integrity: artifacts/results persisted with signatures; deletion/compaction must preserve chain hashes.</p> <p>Minimum modules to enforce:</p> <ul> <li><code>core/runtime/execution_plan.py</code> (plan fingerprint, randomness labels)</li> <li><code>core/runtime/execution_session.py</code> (state machine, contract alignment)</li> <li><code>core/contracts/execution_contract.py</code> + <code>core/contracts/determinism.py</code></li> <li><code>domain/execution_requests/plan.py</code> (capability + contract checks)</li> <li><code>domain/provenance/replay.py</code> (provenance gate)</li> <li><code>core/invariants.py</code> + <code>core/contracts/invariants.py</code> (guardrails)</li> </ul> <p>Everything else is supportive. If removed, these must remain intact for vex to stay itself.</p>"},{"location":"spec/mental_model/","title":"Mental model (non-negotiable)","text":"<p>This file is the single-page spine for bijux-vex v0.1.0. Read this before any other doc.</p>"},{"location":"spec/mental_model/#what-an-execution-is","title":"What an execution is","text":"<ul> <li>A <code>VectorExecution</code> = <code>(ExecutionRequest + ExecutionPlan + ExecutionContract + VectorSource + RandomnessProfile + ExecutionSession)</code>.</li> <li>An execution always produces two artifacts: an immutable <code>ExecutionResult</code> (with cost + determinism report) and an <code>ExecutionArtifact</code> lineage entry in the ledger.</li> <li>Execution identity is <code>ExecutionSignature(request, plan, contract, randomness, parameters, vectors)</code> and is hash-stable.</li> </ul>"},{"location":"spec/mental_model/#what-is-guaranteed","title":"What is guaranteed","text":"<ul> <li>If <code>ExecutionContract == DETERMINISTIC</code>, replay under the same signature MUST produce bit-identical results and matching <code>results_fingerprint</code>.</li> <li>If <code>ExecutionContract == NON_DETERMINISTIC</code> (experimental), replay MUST stay within declared <code>reproducibility_bounds</code> and emit a <code>DeterminismReport</code> describing randomness sources and bounds.</li> <li>Provenance is mandatory: replay is only legal when a stored <code>ExecutionResult</code> exists for the artifact.</li> <li>Budgets are enforced pre- and mid-plan; overruns result in <code>PARTIAL</code> status with <code>BudgetExceededError</code> provenance.</li> </ul>"},{"location":"spec/mental_model/#what-is-not-guaranteed","title":"What is not guaranteed","text":"<ul> <li>No persistence semantics beyond the execution ledger; this is not a vector DB.</li> <li>No implicit fallbacks: ANN runners MUST declare bounds; deterministic fallbacks are explicit.</li> <li>No silent retries: <code>InvariantError</code> and ABI violations are terminal.</li> <li>No execution without declared contract, intent, and session randomness policy.</li> </ul>"},{"location":"spec/mental_model/#replay-legality","title":"Replay legality","text":"<ul> <li>Legal replay requires: matching contract, stored <code>ExecutionResult</code>, and compatible ABI fingerprint.</li> <li>Deterministic replay: must produce identical <code>results_fingerprint</code>; mismatch is a failure.</li> <li>Non-deterministic replay: may diverge, but divergence MUST be recorded in <code>ReplayOutcome.details</code> and <code>DeterminismReport</code>.</li> <li>Replay is illegal if provenance is missing, contract mismatches, ABI fingerprint changed, or ledger is compacted past the required chain.</li> </ul>"},{"location":"spec/nd_profiles/","title":"ND Search Profiles","text":"<p>ND search profiles provide explicit, user-friendly quality controls without requiring ANN expertise.</p> <p>Profiles map to backend parameters. Current defaults (reference runner):</p> <ul> <li><code>fast</code>: low latency, lower recall  </li> <li><code>M=8</code>, <code>ef_search=20</code></li> <li><code>balanced</code>: default quality/latency tradeoff  </li> <li><code>M=16</code>, <code>ef_search=50</code></li> <li><code>accurate</code>: higher recall, higher latency  </li> <li><code>M=32</code>, <code>ef_search=100</code></li> </ul> <p>Additional knobs:</p> <ul> <li><code>nd_target_recall</code>: raises <code>ef_search</code> to meet a recall target where possible.</li> <li><code>nd_latency_budget_ms</code>: caps <code>ef_search</code> for latency targets. If this reduces quality, the downgrade is logged.</li> </ul> <p>If a backend cannot honor these settings, it must refuse or log an explicit downgrade.</p>"},{"location":"spec/non_deterministic_execution/","title":"Non-deterministic execution (ND) semantics","text":"<p>ND execution is first-class at the contract level but remains experimental in behavior in v0.2.x. It is not a best-effort mode.</p> <ul> <li>Inputs and parameters must be deterministic (explicit seeds, declared randomness sources).</li> <li>Allowed divergence: ranking/score differences within declared approximation bounds; provenance must record randomness sources.</li> <li>Replay semantics: distribution-consistent. Replays MUST emit divergence envelopes, not equality, and MUST fail if randomness metadata is missing.</li> <li>Backends MUST declare whether they support ND; refusal is contractual, not an invariant failure.</li> <li>ND execution MAY legally fail with <code>NDExecutionUnavailableError</code> if no ANN backend is available; callers must provide ANN support or choose deterministic contracts.</li> <li>Every ND result MUST include:</li> <li><code>ApproximationReport</code> (recall, displacement, distance error, algorithm, backend, randomness_sources, fallback flag)</li> <li><code>DeterminismReport</code> with reproducibility bounds and randomness used.</li> </ul> <p>Code mapping: see <code>src/bijux_vex/core/contracts/execution_contract.py</code>, <code>src/bijux_vex/domain/execution_requests/postprocess.py</code>, <code>src/bijux_vex/domain/provenance/replay.py</code>, <code>tests/conformance/test_execution_contracts.py</code>.</p>"},{"location":"spec/provenance_schema/","title":"Provenance Schema (extension)","text":"<p>Provenance is the audit surface for execution results. The schema is additive and explicit.</p>"},{"location":"spec/provenance_schema/#new-fields-v020","title":"New fields (v0.2.0)","text":"<p>The provenance output may include:</p> <ul> <li><code>embedding_source</code></li> <li><code>embedding_determinism</code></li> <li><code>embedding_seed</code></li> <li><code>embedding_model_version</code></li> <li><code>embedding_provider</code></li> <li><code>embedding_device</code></li> <li><code>embedding_dtype</code></li> <li><code>vector_store_backend</code></li> <li><code>vector_store_uri_redacted</code></li> <li><code>vector_store_index_params</code></li> <li><code>execution_contract_status</code> (stable vs experimental)</li> </ul> <p>These fields are optional today because not every run uses embeddings or a vector store, but the schema is reserved.</p>"},{"location":"spec/provenance_schema/#where-provenance-appears","title":"Where provenance appears","text":"<ul> <li><code>explain_result</code> output (CLI/API <code>explain</code> flow)</li> <li>Stored execution results for replay and audit</li> </ul>"},{"location":"spec/provenance_schema/#compatibility","title":"Compatibility","text":"<p>This is an additive extension: v0.1.x readers should tolerate missing fields; v0.2.x guarantees the fields are present (may be <code>null</code>).</p>"},{"location":"spec/read_this_first/","title":"bijux-vex \u2014 read this first","text":"<p>bijux-vex is a vector execution engine. It MUST run vector computations under explicit execution contracts, record the consequences, and make determinism vs. non-determinism auditable.</p>"},{"location":"spec/read_this_first/#what-vector-execution-means","title":"What vector execution means","text":"<ul> <li>Inputs are execution requests (text or vectors) routed through explicit plans.</li> <li>Backends are execution substrates, not storage layers.</li> <li>Artifacts are replayable records of how execution happened, not generic indexes.</li> </ul>"},{"location":"spec/read_this_first/#deterministic-vs-non-deterministic-contracts","title":"Deterministic vs non-deterministic contracts","text":"<ul> <li>Deterministic: bit-stable, replay MUST match exactly, no hidden randomness MAY exist.</li> <li>Non-deterministic (experimental): randomness MUST be declared, bounded, and audited; replay MUST check distributional consistency within declared bounds.</li> </ul>"},{"location":"spec/read_this_first/#why-ann-is-treated-as-execution-not-indexing","title":"Why ANN is treated as execution (not indexing)","text":"<ul> <li>ANN choices (graph walks, sampling, pruning) MUST be treated as execution-time decisions.</li> <li>Backends MUST refuse deterministic contracts when they cannot honor exactness.</li> <li>Approximation metadata (MUST include randomness sources and reproducibility bounds) is part of the execution artifact.</li> </ul>"},{"location":"spec/read_this_first/#replay-as-a-first-class-invariant","title":"Replay as a first-class invariant","text":"<ul> <li>Replay MUST mean \u201cre-run the same execution plan under the same contract.\u201d</li> <li>Deterministic replay \u21d2 equality; non-deterministic replay \u21d2 declared envelope.</li> <li>Provenance chains MUST include contract, randomness profile, and artifact signature.</li> </ul>"},{"location":"spec/read_this_first/#typing-philosophy","title":"Typing philosophy","text":"<ul> <li>Runtime contracts and invariants are primary; static typing is advisory.</li> <li>Type checkers MUST NOT be treated as soundness gates. Invariants, provenance, and conformance tests enforce correctness.</li> <li><code>ExecutionIntent</code> is represented canonically as intent strings (<code>exact_validation</code>, <code>reproducible_research</code>, <code>exploratory_search</code>, <code>production_retrieval</code>); the enum is a convenience veneer only.</li> </ul> <p>All other spec documents link back here as the canonical mental model.</p>"},{"location":"spec/refusals/","title":"What bijux-vex refuses to be","text":"<ul> <li>Not a vector database: no storage SLAs, no CRUD API beyond execution ingestion.</li> <li>Not a retrieval framework: no RAG orchestration, no ranking pipelines beyond execution plans.</li> <li>Not an embedding service: no model hosting or embedding generation.</li> <li>Not a serving layer: no latency/availability guarantees, budgets are experimental not production SLAs.</li> <li>Not a benchmarking suite: comparisons exist for contract enforcement, not leaderboard results.</li> <li>Not a reasoning engine: vector execution only.</li> </ul> <p>Intentionally missing abstractions:</p> <ul> <li>No schema migration helpers for embeddings</li> <li>No plug-and-play ANN plugin registry beyond declared runners</li> <li>No automatic fallback unless declared by the runner/plan</li> <li>No implicit retries on invariant/ABI violations</li> </ul>"},{"location":"spec/system_contract/","title":"System contract","text":"<p>bijux-vex is a vector execution engine. The following requirements are normative:</p> <ul> <li>The system MUST treat vector execution as the core unit; storage is supporting only.</li> <li>Deterministic executions MUST be bit-stable and MUST NOT contain hidden randomness.</li> <li>Non-deterministic executions MUST declare randomness sources, budgets, and reproducibility bounds; replay MUST verify within those bounds.</li> <li>Non-deterministic/ANN behavior is experimental until ANN graduation criteria are met.</li> <li>Replay MUST mean re-running the same plan under the same contract; deterministic replay MUST match exactly, ND replay MUST stay within declared envelopes.</li> <li>Backends MUST refuse contracts they cannot honor.</li> <li>Absence of an ANN backend is a valid state; ND requests MAY fail with a contractual capability error (<code>NDExecutionUnavailableError</code>).</li> <li>bijux-vex MUST NOT position itself as a vector DB, embedding system, RAG stack, or serving layer.</li> <li>Public API modules (stable): <code>bijux_vex.core.types</code>, <code>bijux_vex.core.contracts.execution_contract</code>, <code>bijux_vex.core.runtime.vector_execution</code>, <code>bijux_vex.contracts.resources</code>, <code>bijux_vex.services.execution_engine</code>, <code>bijux_vex.api.v1</code>. Everything else is internal.</li> </ul> <p>Any code path or API that violates these statements is a defect.</p>"},{"location":"spec/vdb_profile/","title":"VEX stance on vector DB semantics","text":"<p>bijux-vex is not a vector database. It provides execution contracts, not storage guarantees. No <code>ExecutionProfile.VDB</code> exists for v0.2.0; any persistence semantics are limited to the execution ledger unless an explicit vector store adapter is selected.</p> <p>Implications:</p> <ul> <li>No CRUD API for vectors beyond fixture ingestion.</li> <li>No serving/read/write SLAs.</li> <li>Any adapter exposing database-like APIs must document why it exists and must not claim DB parity.</li> </ul>"},{"location":"spec/vectorstore_adapter/","title":"VectorStoreAdapter (interface contract)","text":"<p>This is the explicit adapter surface for external vector stores. v0.2.0 includes a local FAISS adapter and a no-op adapter for explicit memory routing.</p>"},{"location":"spec/vectorstore_adapter/#interface","title":"Interface","text":"<p>Location: <code>src/bijux_vex/infra/adapters/vectorstore.py</code></p> <p>Methods:</p> <ul> <li><code>connect()</code></li> <li><code>insert(vectors, metadata)</code></li> <li><code>query(vector, k, mode)</code></li> <li><code>delete(ids)</code></li> </ul>"},{"location":"spec/vectorstore_adapter/#contract-notes","title":"Contract notes","text":"<ul> <li>No defaults: adapters must be selected explicitly (see <code>docs/design/vector_store_opt_in.md</code>).</li> <li>No silent fallbacks: failures are terminal and must surface as explicit errors.</li> <li>Adapter implementations live under <code>src/bijux_vex/infra/adapters/</code>.</li> <li>Registry: <code>src/bijux_vex/infra/adapters/vectorstore_registry.py</code> resolves adapters by name.</li> </ul>"},{"location":"spec/vocabulary/","title":"Vocabulary (authoritative)","text":"<ul> <li>Execution: interpreting an <code>ExecutionPlan</code> under an <code>ExecutionContract</code> against a <code>VectorSource</code>, producing an <code>ExecutionResult</code> + provenance.</li> <li>ExecutionPlan: immutable plan describing algorithm, contract, k, scoring, randomness sources, bounds; fingerprinted.</li> <li>ExecutionSession: lifecycle holder (state machine) tying plan + artifact + randomness + budget.</li> <li>Artifact: <code>ExecutionArtifact</code> linking corpus/vector fingerprints to execution signature; persisted in ledger.</li> <li>Provenance: ledger records (artifacts, results, audit chain) required for replay and comparison.</li> <li>Determinism: contract dimension; deterministic \u21d2 bit-identical replay; non_deterministic \u21d2 bounded divergence with <code>DeterminismReport</code>.</li> <li>Replay: re-running an execution with the same contract/ABI; deterministic checks equality, ND checks envelope. Replayable does not mean cached; it means re-execution is possible under the same contract.</li> <li>Comparison: structured diff between executions (overlap, recall delta, rank instability), exact vs approximate.</li> <li>Execution fidelity: mode expressing how close results adhere to exact semantics (deterministic exact vs ND approximate).</li> <li>Stability: deterministic surfaces are frozen; ND/ANN is stable_bounded at the contract level but experimental in behavior (outcomes vary within declared envelopes).</li> <li>Reproducibility: ability to recreate execution behavior under the same contract/plan/randomness (deterministic \u21d2 equality, ND \u21d2 bounded envelope).</li> </ul>"},{"location":"spec/examples/ann_execution/","title":"ANN execution example","text":"<p>ANN execution is experimental until graduation criteria are met.</p> <pre><code>bijux vex execute --artifact-id art-1 --vector \"[0.3,0.4]\" --top-k 1 \\\n  --execution-contract non_deterministic --execution-intent exploratory_search --execution-mode bounded \\\n  --randomness-seed 1 --randomness-sources reference_ann_hnsw --randomness-bounded \\\n  --max-latency-ms 10 --max-memory-mb 10 --max-error 0.2\n</code></pre> <p>Expected:</p> <ul> <li>ANN algorithm selected, randomness sources recorded</li> <li>ApproximationReport persisted with recall/rank displacement</li> <li>DeterminismReport present with reproducibility bounds</li> </ul> <p>Failure example:</p> <ul> <li>Missing budget or randomness profile \u21d2 invariant failure before execution.</li> </ul>"},{"location":"spec/examples/deterministic_replay/","title":"Deterministic replay example","text":"<pre><code>bijux vex replay --request-text \"hello\"\n</code></pre> <p>Expected:</p> <ul> <li>Replay uses stored plan + artifact; no live vector source mutation.</li> <li>Results match original execution exactly; mismatch raises InvariantError.</li> </ul> <p>Failure example:</p> <ul> <li>Altered plan fingerprint \u21d2 replay refused.</li> </ul>"},{"location":"spec/examples/exact_execution/","title":"Exact execution example","text":"<pre><code>bijux vex ingest --doc \"hello\" --vector \"[0.1,0.2]\"\nbijux vex materialize --execution-contract deterministic\nbijux vex execute --artifact-id art-1 --vector \"[0.1,0.2]\" --top-k 1 \\\n  --execution-contract deterministic --execution-intent exact_validation --execution-mode strict\n</code></pre> <p>Expected:</p> <ul> <li>deterministic plan, no randomness sources</li> <li>execution artifact with no approximation report</li> <li>replay returns identical results</li> </ul> <p>Failure example:</p> <ul> <li>If backend lacks deterministic support, command fails with InvariantError.</li> </ul>"},{"location":"spec/examples/forcing_case/","title":"Forcing scenario: ND ANN with budget exhaustion and replay divergence","text":"<p>Steps (MUST):</p> <ul> <li>Execute a NON_DETERMINISTIC ANN request with a strict budget (<code>max_vectors=0</code>, low latency).</li> <li>Allow partial execution; status MUST be <code>PARTIAL</code>.</li> <li>Fallback deterministic path MUST be used when ANN cannot proceed under budget.</li> <li>Replay MUST re-run the plan and detect divergence against the baseline fingerprint.</li> </ul> <p>Invariants (IDs):</p> <ul> <li>INV-020: Randomness required for ND execution.</li> <li>INV-021: Budget exhaustion recorded, status PARTIAL.</li> <li>INV-010: Contract alignment enforced.</li> <li>INV-030: Plan fingerprint must not mutate between execution and replay.</li> </ul> <p>Expected behavior:</p> <ul> <li>First run yields partial results and signature.</li> <li>Replay with the baseline fingerprint produces a different results fingerprint and details indicating nondeterministic divergence.</li> <li>Fallback path is exercised during replay to make divergence observable.</li> </ul>"},{"location":"spec/examples/nd_execution_with_audit/","title":"Non-deterministic execution with audit","text":"<p>Non-deterministic execution is experimental in behavior; provenance must label it accordingly.</p> <pre><code>bijux vex execute --artifact-id art-1 --vector \"[0.5,0.6]\" --top-k 1 \\\n  --execution-contract non_deterministic --execution-intent exploratory_search --execution-mode bounded \\\n  --randomness-seed 1 --randomness-sources reference_ann_hnsw --randomness-bounded \\\n  --max-latency-ms 50 --max-memory-mb 20 --max-error 0.2\n</code></pre> <p>Expected:</p> <ul> <li>RandomnessProfile captured (seed, sources, bounded flag, budget).</li> <li>DeterminismReport includes randomness sources and reproducibility bounds.</li> <li>ApproximationReport shows recall and displacement; status may be PARTIAL if budgets trigger.</li> </ul> <p>Failure example:</p> <ul> <li>Missing randomness profile or budget triggers invariant failure; execution does not start.</li> </ul>"},{"location":"spec/examples/ugly_truth/","title":"Limitations and failure modes (descriptive)","text":"<p>Scenario: ND ANN execution with budget exhaustion, approximation, provenance, and replay mismatch.</p> <p>Steps (CLI narrative):</p> <ol> <li><code>bijux vex materialize --execution-contract non_deterministic</code></li> <li><code>bijux vex execute --artifact-id art-1 --vector \"[...]\" --top-k 1 --execution-contract non_deterministic --execution-intent exploratory_search --execution-mode bounded --randomness-seed 1 --randomness-sources reference_ann_hnsw --randomness-bounded --max-latency-ms 1 --max-memory-mb 1 --max-error 0.2</code></li> <li>Execution returns PARTIAL with <code>BudgetExceededError</code> provenance and <code>DeterminismReport</code>.</li> <li>Ledger stores <code>ExecutionResult</code> + artifact signature.</li> <li><code>bijux vex replay --request-text \"...\"</code> \u2192 mismatch allowed but recorded; <code>ReplayOutcome.details</code> carries divergence and randomness sources.</li> <li><code>bijux vex compare --vector \"[...]\" --execution-intent exact_validation</code> \u2192 overlap/recall deltas highlight approximation loss.</li> </ol> <p>What it proves:</p> <ul> <li>Budgets abort mid-plan, not post-hoc.</li> <li>ND replay is legal but must declare divergence.</li> <li>Provenance is required; replay without ledger state fails fast.</li> <li>Approximation is auditable, not silent.</li> </ul>"},{"location":"spec/failure_narratives/budget_exhaustion/","title":"Failure narrative: budget exhaustion","text":"<ul> <li>Invariant: INV-021 (budget exhaustion must be explicit and halt progress).</li> <li>Trigger: ExecutionBudget limit (vectors/latency/probes) exceeded mid-plan.</li> <li>Response:</li> <li>Status becomes PARTIAL.</li> <li>BudgetExceededError (value) recorded with dimension.</li> <li>Replay still allowed; divergence expected for ND.</li> <li>Evidence:</li> <li>ExecutionResult.status == PARTIAL</li> <li>Failure reason includes <code>budget_exhausted_&lt;dimension&gt;</code></li> <li>Scenario: docs/spec/examples/forcing_case.md; tests/scenarios/test_forcing_case.py</li> </ul>"},{"location":"user/anti_goals/","title":"Anti\u2011Goals","text":"<p>Bijux\u2011Vex is intentionally not:</p> <ul> <li>A vector database</li> <li>A RAG framework</li> <li>A hosted service</li> <li>An auto\u2011embedding pipeline</li> <li>Best\u2011effort correctness</li> </ul> <p>This keeps the system honest and auditable. If you need any of those, use a dedicated tool and integrate explicitly.</p>"},{"location":"user/before_production_checklist/","title":"Before Production Checklist","text":"<ul> <li>Deterministic or ND mode chosen explicitly</li> <li>ND budgets and target recall configured</li> <li>Resource limits configured</li> <li>Logging and provenance retention enabled</li> <li>Backup and rebuild plan documented</li> <li>Debug-bundle tested in staging</li> </ul>"},{"location":"user/byo_vectors_vs_embeddings/","title":"BYO Vectors vs Auto-Embeddings","text":"<p>Bijux-Vex treats user-provided vectors as the primary, most explicit workflow. Auto-embeddings are available, but only when you opt in with an explicit model.</p>"},{"location":"user/byo_vectors_vs_embeddings/#bring-your-own-vectors-recommended-for-control","title":"Bring Your Own Vectors (Recommended for control)","text":"<ul> <li>Maximum determinism: you control the embedding model, version, and runtime.</li> <li>Full auditability: vectors can be regenerated outside Bijux-Vex.</li> <li>No hidden costs or persistence.</li> </ul>"},{"location":"user/byo_vectors_vs_embeddings/#auto-embeddings-explicit-opt-in","title":"Auto-Embeddings (Explicit opt-in)","text":"<ul> <li>Convenience: provide documents only and specify <code>--embed-model</code>.</li> <li>Provider-specific determinism: some providers are deterministic only under certain devices/versions.</li> <li>Provenance is captured (provider, model version, device, dtype).</li> </ul>"},{"location":"user/byo_vectors_vs_embeddings/#decision-guide","title":"Decision Guide","text":"<ul> <li>Choose BYO vectors when reproducibility, auditability, or model governance matters.</li> <li>Choose auto-embeddings when speed and simplicity outweigh strict determinism.</li> </ul>"},{"location":"user/byo_vectors_vs_embeddings/#cli-examples","title":"CLI Examples","text":"<p>Provide vectors explicitly:</p> <pre><code>bijux vex ingest --doc \"hello\" --vector \"[0.1,0.2,0.3]\"\n</code></pre> <p>Auto-embed explicitly:</p> <pre><code>bijux vex ingest --doc \"hello\" --embed-model \"all-MiniLM-L6-v2\"\n</code></pre> <p>Optional caching:</p> <pre><code>bijux vex ingest --doc \"hello\" --embed-model \"all-MiniLM-L6-v2\" --cache-embeddings sqlite\n</code></pre> <p>Note: auto-embeddings require the optional <code>embeddings</code> extra (<code>sentence-transformers</code>).</p>"},{"location":"user/choose_execution_mode/","title":"How to Choose Execution Mode","text":"<p>Do you need auditability?</p> <ul> <li>Yes \u2192 deterministic exact.</li> <li>No \u2192 continue.</li> </ul> <p>Do you need speed at scale?</p> <ul> <li>Yes \u2192 ND bounded.</li> <li>No \u2192 deterministic exact.</li> </ul> <p>Can you tolerate approximation?</p> <ul> <li>Yes \u2192 ND bounded with witness.</li> <li>No \u2192 deterministic exact.</li> </ul> <p>CLI flags</p> <ul> <li>Deterministic: <code>--execution-contract deterministic --execution-mode strict</code></li> <li>ND bounded: <code>--execution-contract non_deterministic --execution-mode bounded</code></li> </ul>"},{"location":"user/common_mistakes/","title":"Common Mistakes &amp; Misconceptions","text":"<p>Determinism</p> <ul> <li>\u201cExact means fast.\u201d It can be slower than ANN at scale.</li> <li>\u201cReplay is optional.\u201d If you care about audits, it is required.</li> </ul> <p>ND</p> <ul> <li>\u201cND is just faster exact.\u201d It is approximate and bounded.</li> <li>\u201cSeeds make ND deterministic.\u201d Seeds help; they don\u2019t replace bounds.</li> </ul> <p>Vector stores</p> <ul> <li>\u201cDeletes are permanent.\u201d Not unless the backend guarantees it.</li> <li>\u201cAll backends are equivalent.\u201d Capabilities differ.</li> </ul>"},{"location":"user/concept_map/","title":"Concept Map","text":""},{"location":"user/concept_map/#contracts","title":"Contracts","text":"<ul> <li>Execution contract defines determinism and replay guarantees.</li> <li>Implicitness contract requires explicit opt-in for persistence and approximation.</li> </ul>"},{"location":"user/concept_map/#determinism-vs-ann","title":"Determinism vs ANN","text":"<ul> <li>Deterministic: bit-identical results when replayed.</li> <li>ANN: approximate results, explicitly labeled experimental until criteria are met.</li> </ul>"},{"location":"user/concept_map/#storage-vs-execution","title":"Storage vs Execution","text":"<ul> <li>Storage holds documents, chunks, vectors, and artifacts.</li> <li>Execution runs algorithms over stored vectors under a declared contract.</li> </ul>"},{"location":"user/concept_map/#provenance","title":"Provenance","text":"<ul> <li>Provenance explains how a result was produced.</li> <li>Embedding metadata and vector store metadata must be present when used.</li> </ul>"},{"location":"user/concept_map/#trust-boundaries","title":"Trust Boundaries","text":"<ul> <li>Execution engine is deterministic only when every component declares determinism.</li> <li>External backends (VDB/ANN) must be explicitly configured.</li> </ul>"},{"location":"user/determinism_analogies/","title":"Determinism by Analogy","text":"<p>Determinism is like a scientific experiment: if you can\u2019t reproduce the results, you don\u2019t know if the result is real.</p> <p>It\u2019s also like accounting: an audit only works if the numbers can be traced back to the original ledger.</p> <p>Replay is your verification step. It is how you prove that a result is not a fluke or a hidden change.</p>"},{"location":"user/determinism_end_to_end/","title":"Deterministic Execution: End-to-End","text":""},{"location":"user/determinism_end_to_end/#why-this-exists","title":"Why this exists","text":"<p>When systems behave differently in staging and production, teams lose weeks to debugging and lose trust in their results. Deterministic execution exists to prevent that drift by making \u201csame input \u2192 same output\u201d an enforceable guarantee.</p> <p>If you skip determinism, you get subtle regressions: scores that change with no code changes, audits that can\u2019t be replayed, and explanations that don\u2019t hold up. This section is for anyone who needs to defend results in production\u2014engineers, auditors, and operators.</p>"},{"location":"user/determinism_end_to_end/#story-scenario","title":"Story / scenario","text":"<p>You deploy a search change, and suddenly rankings differ between staging and prod. Users report inconsistent behavior, and the root cause is hidden randomness in the retrieval path.</p>"},{"location":"user/determinism_end_to_end/#what-usually-goes-wrong","title":"What usually goes wrong","text":"<ul> <li>Approximate search sneaks into \u201cexact\u201d paths.</li> <li>Backends or embeddings change behavior without being captured in artifacts.</li> <li>Replay claims are made without a matching index or config.</li> </ul>"},{"location":"user/determinism_end_to_end/#how-bijux-vex-handles-it","title":"How Bijux-Vex handles it","text":"<p>Deterministic execution means exact search, stable ordering, and replayable results. If any component would violate determinism, the system refuses and explains why.</p>"},{"location":"user/determinism_end_to_end/#what-trade-offs-remain","title":"What trade-offs remain","text":"<ul> <li>Determinism can cost latency or scale.</li> <li>Some backends cannot provide exact guarantees.</li> </ul>"},{"location":"user/determinism_end_to_end/#where-to-go-deeper","title":"Where to go deeper","text":"<ul> <li><code>docs/user/deterministic_replay.md</code></li> <li><code>docs/user/determinism_refusals.md</code></li> </ul> <p>Requirements</p> <ul> <li>Execution contract: <code>deterministic</code></li> <li>Exact-capable backend</li> <li>No ND-only features (ANN, approximate filters)</li> </ul> <p>Supported backends</p> <ul> <li>Memory and SQLite adapters are deterministic exact.</li> <li>FAISS exact is deterministic if configured with exact index types.</li> </ul> <p>What breaks determinism</p> <ul> <li>ANN indices or approximate search.</li> <li>Non-deterministic embeddings without explicit declarations.</li> <li>Backends that cannot guarantee exact search.</li> </ul> <p>Replay semantics</p> <ul> <li>Replay is allowed only when fingerprints match.</li> <li>Replay is refused when index hash, config hash, or backend signature differs.</li> </ul>"},{"location":"user/determinism_end_to_end/#common-misunderstandings","title":"Common misunderstandings","text":"<ul> <li>\u201cExact means fast.\u201d It can be slower than ANN, especially at scale.</li> <li>\u201cReplay means same API payload.\u201d Replay also requires matching artifacts and hashes.</li> <li>\u201cDeterminism is optional.\u201d If you need audits, it is a requirement, not a preference.</li> </ul>"},{"location":"user/determinism_end_to_end/#when-to-stop-caring-about-determinism","title":"When to stop caring about determinism","text":"<p>If you only need approximate similarity for exploration, recommendations, or early-stage discovery, ND may be sufficient. Use deterministic execution when you need audits, regulatory defensibility, or rigorous regression checks. The key is to choose this consciously, not by accident.</p> <p>CLI example</p> <pre><code>bijux vex ingest --doc \"hello\" --vector \"[0.0, 1.0, 0.0]\" \\\n  --vector-store memory\n\nbijux vex materialize --execution-contract deterministic \\\n  --vector-store memory\n\nbijux vex execute --artifact-id art-1 \\\n  --execution-contract deterministic --execution-intent exact_validation \\\n  --execution-mode strict --vector \"[0.0, 1.0, 0.0]\"\n</code></pre> <p>API example</p> <pre><code>POST /execute\n{\n  \"artifact_id\": \"art-1\",\n  \"vector\": [0.0, 1.0, 0.0],\n  \"top_k\": 5,\n  \"execution_contract\": \"deterministic\",\n  \"execution_intent\": \"exact_validation\",\n  \"execution_mode\": \"strict\"\n}\n</code></pre>"},{"location":"user/determinism_failure_story/","title":"Determinism Failure Story","text":"<p>A team ships a ranking update that looks fine in staging. In production, results drift. Users complain, dashboards light up, and debugging drags on for weeks.</p> <p>The root cause was hidden non-determinism: an ANN index slipped into an exact path and an embedding update wasn\u2019t captured in artifacts. No one could prove what happened because replay didn\u2019t match.</p> <p>With Bijux\u2011Vex, this would have been refused immediately. The system would have reported a deterministic violation and blocked the rollout until the exact contract was satisfied.</p>"},{"location":"user/determinism_guarantees_table/","title":"Determinism Guarantees vs Best\u2011Effort","text":"Category Description Why it exists Guaranteed Exact search, canonical ordering, replay when hashes match Needed for audit and regression proof Best\u2011effort Performance targets, optional backend optimizations Varies by environment Not guaranteed Cross\u2011backend numeric equality, approximate search stability Outside the deterministic contract"},{"location":"user/determinism_guide/","title":"Determinism Guide","text":""},{"location":"user/determinism_guide/#deterministic-exact-pipeline","title":"Deterministic Exact Pipeline","text":"<ul> <li>Use <code>--execution-contract deterministic</code>.</li> <li>Use a vector store that advertises <code>deterministic_exact = true</code>.</li> <li>Provide vectors explicitly, or use embeddings with declared determinism.</li> </ul>"},{"location":"user/determinism_guide/#what-breaks-determinism","title":"What Breaks Determinism","text":"<ul> <li>ANN execution without declared randomness.</li> <li>Vector stores that cannot guarantee exact search.</li> <li>Embedding providers without determinism metadata.</li> </ul>"},{"location":"user/determinism_guide/#using-refusal-messages","title":"Using Refusal Messages","text":"<p>When the system refuses a run:</p> <ol> <li>Read the <code>reason</code> field in the error payload.</li> <li>Apply the <code>remediation</code> step.</li> <li>Retry with explicit randomness if using ANN.</li> </ol>"},{"location":"user/determinism_refusals/","title":"Determinism Refusal Guide","text":""},{"location":"user/determinism_refusals/#why-this-exists","title":"Why this exists","text":"<p>Refusals are how the system protects you from hidden correctness failures. They are not errors to \u201cwork around.\u201d They are early warnings that the execution you asked for cannot be trusted.</p> <p>If you ignore refusals, you get silent approximation, misleading audits, and outputs that cannot be explained later. This section is for anyone who needs defensible results in production.</p>"},{"location":"user/determinism_refusals/#story-scenario","title":"Story / scenario","text":"<p>A team ships a fix, but results still drift. The root cause is an ANN index used in a deterministic path. A refusal would have made this visible immediately.</p>"},{"location":"user/determinism_refusals/#what-usually-goes-wrong","title":"What usually goes wrong","text":"<ul> <li>Teams assume a backend can do exact search.</li> <li>ND features creep into deterministic execution.</li> <li>Replay is attempted without matching artifacts.</li> </ul>"},{"location":"user/determinism_refusals/#how-bijux-vex-handles-it","title":"How Bijux-Vex handles it","text":"<p>The system refuses with a structured payload and remediation guidance.</p>"},{"location":"user/determinism_refusals/#what-trade-offs-remain","title":"What trade-offs remain","text":"<ul> <li>Some refusals require you to rebuild indexes or switch modes.</li> <li>There is no \u201cforce\u201d flag for deterministic correctness.</li> </ul>"},{"location":"user/determinism_refusals/#where-to-go-deeper","title":"Where to go deeper","text":"<ul> <li><code>docs/user/deterministic_replay.md</code></li> <li><code>docs/user/determinism_end_to_end.md</code></li> </ul> <p>Common refusal reasons</p> <ul> <li><code>backend_capability_missing</code>: The selected backend does not support deterministic exact.</li> <li><code>determinism_violation</code>: A requested mode or component is non-deterministic.</li> <li><code>index_mismatch</code>: Index hash or parameters do not match the artifact.</li> <li><code>randomness_required</code>: ND-only randomness was requested under deterministic contract.</li> </ul> <p>Example refusal payload</p> <pre><code>{\n  \"error\": {\n    \"reason\": \"determinism_violation\",\n    \"message\": \"[INV-203] What happened: deterministic execution requested with ANN index.\\nWhy: ANN is non-deterministic.\\nHow to fix: use exact index or switch to ND contract.\\nWhere to learn more: docs/user/determinism_refusals.md\",\n    \"remediation\": \"Use exact mode or explicitly request ND with bounds.\"\n  }\n}\n</code></pre> <p>How to resolve</p> <ul> <li>Use an exact backend and exact index mode.</li> <li>Remove ANN-only flags.</li> <li>Rebuild artifacts to match the expected configuration.</li> </ul> <p>When override is allowed</p> <ul> <li>Deterministic refusals are not overridable. If you need approximation, use ND explicitly.</li> </ul>"},{"location":"user/determinism_refusals/#common-misunderstandings","title":"Common misunderstandings","text":"<ul> <li>\u201cRefusals mean the system is broken.\u201d They mean the system is protecting you.</li> <li>\u201cI can just retry.\u201d If the inputs are wrong, retrying won\u2019t help.</li> <li>\u201cIt\u2019s safe to ignore the warning.\u201d It is not safe if you need correctness.</li> </ul>"},{"location":"user/determinism_stop_caring/","title":"When to Stop Caring About Determinism","text":"<p>Determinism is essential when you need audits, legal defensibility, or strict regression checks. It is less critical when you are exploring, prototyping, or optimizing latency.</p> <p>If the cost of exact replay is higher than the cost of occasional drift, ND may be the right choice. The key is to decide this consciously and document the trade-off.</p>"},{"location":"user/deterministic_replay/","title":"Deterministic Replay","text":""},{"location":"user/deterministic_replay/#why-this-exists","title":"Why this exists","text":"<p>Replay is how you prove that a result is real and repeatable. Without replay, you can\u2019t audit, you can\u2019t compare changes safely, and you can\u2019t trust regression tests.</p> <p>If you skip replay, you risk shipping changes that look fine in one run and break quietly later. This section is for teams that care about evidence, not guesses.</p>"},{"location":"user/deterministic_replay/#story-scenario","title":"Story / scenario","text":"<p>A ranking change seems safe, but users complain a week later. Replay against the original artifact would have shown the drift immediately.</p>"},{"location":"user/deterministic_replay/#what-usually-goes-wrong","title":"What usually goes wrong","text":"<ul> <li>Artifacts are rebuilt implicitly, changing the index.</li> <li>Backends change versions without tracking it.</li> <li>Replay is attempted with a different config.</li> </ul>"},{"location":"user/deterministic_replay/#how-bijux-vex-handles-it","title":"How Bijux-Vex handles it","text":"<p>Replay is allowed only when fingerprints match. Otherwise it refuses with a precise reason.</p>"},{"location":"user/deterministic_replay/#what-trade-offs-remain","title":"What trade-offs remain","text":"<ul> <li>Replay requires stable artifacts and storage.</li> <li>Some environments cannot guarantee the same backend versions.</li> </ul>"},{"location":"user/deterministic_replay/#where-to-go-deeper","title":"Where to go deeper","text":"<ul> <li><code>docs/user/determinism_refusals.md</code></li> <li><code>docs/user/determinism_end_to_end.md</code></li> </ul> <p>When replay is allowed</p> <ul> <li>Same artifact ID and index hash.</li> <li>Same backend signature and parameters.</li> <li>Same execution contract and intent.</li> </ul> <p>When replay is refused</p> <ul> <li>Index hash mismatch.</li> <li>Backend version mismatch that invalidates determinism.</li> <li>Configuration or parameter drift.</li> </ul> <p>How fingerprints are checked</p> <ul> <li>Vector fingerprints ensure the corpus is identical.</li> <li>Config and algorithm fingerprints ensure the plan matches.</li> <li>Backend signature ensures the same deterministic guarantees.</li> </ul> <p>What \u201cmatches\u201d means</p> <ul> <li>Deterministic results must be bit-identical and ordered by the canonical query contract.</li> <li>Any deviation is reported as a mismatch with a structured refusal.</li> </ul>"},{"location":"user/deterministic_replay/#common-misunderstandings","title":"Common misunderstandings","text":"<ul> <li>\u201cReplay is just re-running the request.\u201d It also requires matching artifacts and hashes.</li> <li>\u201cClose enough is fine.\u201d Deterministic replay is exact by definition.</li> <li>\u201cReplay is optional.\u201d If you need audits, it is required.</li> </ul>"},{"location":"user/embedding_lifecycle/","title":"Embedding Lifecycle","text":"<p>Embeddings are data with provenance. They must be explicit and auditable.</p> <p>Embedding providers</p> <ul> <li>Providers are selected explicitly by name.</li> <li>No implicit model selection is allowed.</li> </ul> <p>Caching rules</p> <ul> <li>Cache is off by default.</li> <li>Cache keys include model id, provider version, and normalization settings.</li> </ul> <p>Determinism implications</p> <ul> <li>Providers must declare deterministic or non-deterministic behavior.</li> <li>ND embedding providers require explicit randomness declaration.</li> </ul> <p>Metadata captured</p> <ul> <li>Provider name, model id, model version, dtype, device, and seed.</li> </ul> <p>Failure handling</p> <ul> <li>Embedding failure is atomic. No partial ingest is written.</li> </ul> <p>Ingest example</p> <pre><code>bijux vex ingest --doc \"hello\" \\\n  --embed-provider sentence-transformers \\\n  --embed-model all-MiniLM-L6-v2 \\\n  --vector-store memory\n</code></pre>"},{"location":"user/execution_mode_comparison/","title":"Execution Mode Comparison","text":"Mode Replayable? Auditable? Fast? Safe for prod? Deterministic (exact) Yes Yes Moderate Yes Deterministic (vector store) Yes Yes Moderate Yes ND bounded Bounded Yes Fast Yes, with checks ND best\u2011effort No Partial Fastest Only with caution"},{"location":"user/experimental_stable_markers/","title":"Stability Markers","text":"<p>Stable</p> <ul> <li>Deterministic execution and replay</li> <li>Provenance schema</li> <li>CLI core commands</li> </ul> <p>Experimental</p> <ul> <li>ND runners and ANN behavior</li> <li>ND tuning and witness verification</li> <li>Remote vector store integrations</li> </ul> <p>Frozen vs evolving</p> <ul> <li>Frozen: execution contracts, query contract, provenance fields</li> <li>Evolving: ND quality metrics and tuning heuristics</li> </ul>"},{"location":"user/external_misuse/","title":"External misuse to avoid","text":"<ul> <li>Treating bijux-vex as a vector DB: there is no CRUD, indexing API, or serving tier; executions are contract-bound.</li> <li>Expecting ANN replay: ND executions provide approximation envelopes and audit but do not promise ANN result equality.</li> <li>Assuming implicit defaults: intents, contracts, and modes are mandatory; unknown strings are rejected.</li> <li>Using ND without budgets: bounded/exploratory modes require explicit budgets and randomness profiles.</li> </ul> <p>Use bijux-vex when you need audited execution comparisons, not managed vector storage.</p>"},{"location":"user/failure_modes_safety/","title":"Failure Modes &amp; Safety","text":"<p>Atomicity guarantees</p> <ul> <li>Ingest and artifact writes are atomic when possible.</li> <li>Partial writes are refused and marked incomplete.</li> </ul> <p>Crashes</p> <ul> <li>Incomplete runs are marked as invalid and excluded from replay or compare.</li> </ul> <p>Partial failures</p> <ul> <li>Remote backends use explicit retry policies.</li> <li>Partial batch failures are detected and surfaced.</li> </ul> <p>Circuit breakers</p> <ul> <li>Repeated ND backend failures trigger fast refusal.</li> <li>Cooldown is explicit and visible in capabilities.</li> </ul> <p>Idempotency</p> <ul> <li>Ingest supports idempotency keys for safe retries.</li> <li>Duplicate detection is explicit and refuses when conflicting.</li> </ul> <p>Example scenario</p> <ul> <li>If a remote upsert times out mid-batch, the retry policy is applied.</li> <li>If duplicates are detected, the system refuses with a remediation message.</li> </ul>"},{"location":"user/freeze_meanings/","title":"Freeze Meanings (Not Code)","text":"<p>These meanings are stable even if implementations evolve:</p> <ul> <li>Deterministic execution = exact, replayable, auditable.</li> <li>ND execution = approximate, bounded, explicitly declared.</li> <li>Refusal = the system cannot meet the requested guarantee.</li> <li>Provenance = structured evidence of what happened and why.</li> </ul>"},{"location":"user/glossary/","title":"Glossary","text":"<p>determinism A property where the same inputs produce the same outputs under the same system and index state.</p> <p>non-determinism (ND) Execution that allows approximation or randomness and must declare its bounds and randomness profile.</p> <p>replay A verification process that re-executes under the same contract and compares results to a prior run.</p> <p>provenance A structured record of inputs, decisions, randomness, and artifacts emitted by an execution.</p> <p>execution artifact A persisted representation of the execution state and index configuration used for later runs.</p> <p>witness An optional verification step for ND that estimates quality by checking against exact results on a subset.</p> <p>approximation A deliberate tradeoff where results may differ from exact in exchange for speed or scale.</p> <p>confidence label A classification derived from ND quality metrics that indicates result stability.</p> <p>refusal A structured response indicating the system will not execute because guarantees cannot be met.</p>"},{"location":"user/how_to_think_with_bijux_vex/","title":"How to Think With Bijux\u2011Vex","text":"<p>Bijux\u2011Vex is a system for making correctness a conscious decision. The core habit it teaches is this: decide what you need to be true, then ask the system to enforce it.</p> <p>Reasoning about correctness</p> <ul> <li>Decide which parts must be deterministic.</li> <li>Treat ND as a tool for speed, not truth.</li> <li>Require explicit randomness when approximation is used.</li> </ul> <p>Choosing trade-offs</p> <ul> <li>If auditability matters, prefer deterministic execution and replay.</li> <li>If latency matters, use ND with explicit budgets and witness checks.</li> </ul> <p>Debugging with provenance</p> <ul> <li>Use provenance to understand \u201cwhat happened\u201d and \u201cwhy.\u201d</li> <li>Compare fingerprints to explain differences between runs.</li> </ul> <p>Evolving safely</p> <ul> <li>Change one variable at a time.</li> <li>Keep old artifacts for replay.</li> <li>When in doubt, let the system refuse and surface the mismatch.</li> </ul> <p>This mindset turns vector search from guesswork into evidence.</p>"},{"location":"user/known_limitations/","title":"Known Limitations","text":"<ul> <li>ND results are not bit\u2011replayable.</li> <li>Remote backends depend on network stability.</li> <li>Large\u2011scale performance is backend\u2011dependent.</li> <li>Some backends do not support filtering or deletes.</li> <li>Not all ND runners are production\u2011grade yet.</li> </ul>"},{"location":"user/misuse/","title":"bijux-vex misuse patterns (real-world)","text":"<p>This page lists ways people are likely to misuse bijux-vex and the exact failure surfaces they will hit.</p> <ul> <li>Treating bijux-vex as a \u201cvector database\u201d: requests that expect CRUD or implicit persistence will fail with <code>InvariantError</code> or <code>BackendCapabilityError</code>; refer to <code>docs/user/not_a_vdb.md</code>.</li> <li>Requesting non-deterministic execution without ANN support: fails with <code>NDExecutionUnavailableError</code> (HTTP 503 / CLI non-zero) and an audit entry explaining missing <code>supports_ann</code>.</li> <li>Supplying string intents or modes: boundary coercion now rejects unknown values with <code>InvariantError</code>.</li> <li>Mixing deterministic replay with ND artifacts: replay refuses with <code>ReplayNotSupportedError</code> and provenance notes the contract mismatch.</li> <li>Ignoring budgets: deterministic runs reject pre-execution if budgets are impossible; ND runs emit <code>BudgetExceededError</code> with provenance.</li> </ul> <p>Always consult the contract docs before extending usage beyond the supported execution model.</p>"},{"location":"user/naming_explained/","title":"Naming Explained","text":"<p>Why \u201cdoctor\u201d?</p> <ul> <li>It diagnoses environment and configuration issues before they become production incidents.</li> </ul> <p>Why \u201cartifact\u201d?</p> <ul> <li>It represents a stable, replayable execution state, not just a file.</li> </ul> <p>Why \u201cprovenance\u201d?</p> <ul> <li>It is evidence: a structured history of what happened and why.</li> </ul>"},{"location":"user/nd_decision_tree/","title":"ND Decision Tree","text":"<p>Do you need speed more than exact replay?</p> <ul> <li>If no: use deterministic exact.</li> <li>If yes: continue.</li> </ul> <p>Is recall critical for user-facing decisions?</p> <ul> <li>If yes: set <code>nd.target_recall</code> and enable witness <code>sample</code> or <code>full</code>.</li> <li>If no: use <code>fast</code> or <code>balanced</code> profile.</li> </ul> <p>Is latency budget strict?</p> <ul> <li>If yes: set <code>nd.latency_budget_ms</code> and accept possible refusal.</li> <li>If no: use <code>accurate</code> profile and larger candidate caps.</li> </ul> <p>Need auditability?</p> <ul> <li>Enable witness mode and keep provenance artifacts.</li> </ul> <p>Recommended starting configs</p> <ul> <li>Fast: <code>profile=fast</code>, <code>witness=off</code>, <code>budget=low</code>.</li> <li>Balanced: <code>profile=balanced</code>, <code>witness=sample</code>.</li> <li>Accurate: <code>profile=accurate</code>, <code>witness=full</code>.</li> </ul>"},{"location":"user/nd_examples/","title":"ND Examples With Interpretation","text":""},{"location":"user/nd_examples/#example-safe-nd-run","title":"Example: Safe ND run","text":"<ul> <li>This run is safe because instability is low and margins are clear.</li> <li>Confidence is high, and witness confirms overlap.</li> </ul>"},{"location":"user/nd_examples/#example-risky-nd-run","title":"Example: Risky ND run","text":"<ul> <li>This run is risky because instability is high and margins are thin.</li> <li>Confidence is low; use witness or switch to deterministic.</li> </ul>"},{"location":"user/nd_examples/#example-refusal","title":"Example: Refusal","text":"<ul> <li>This run refused because the budget was too tight for the requested recall.</li> <li>Increase the budget or lower the recall target.</li> </ul>"},{"location":"user/nd_execution_model/","title":"ND Execution Model Explained","text":""},{"location":"user/nd_execution_model/#why-this-exists","title":"Why this exists","text":"<p>ND is where speed meets uncertainty. It powers real workloads like search and recommendations, but it can also hide risk if treated casually. This doc explains ND as a tool with boundaries, not a warning label.</p> <p>If you skip this, you may ship fast results that drift, weaken audits, or behave unpredictably under load. This section is for engineers and operators who want speed without losing control.</p>"},{"location":"user/nd_execution_model/#story-scenario","title":"Story / scenario","text":"<p>A recommendation pipeline switches to ANN for scale. Latency drops, but results become unstable and user behavior changes. Without ND visibility, the team can\u2019t explain why.</p>"},{"location":"user/nd_execution_model/#what-usually-goes-wrong","title":"What usually goes wrong","text":"<ul> <li>Approximation is introduced without explicit bounds.</li> <li>Randomness is not declared or tracked.</li> <li>Budgets are exceeded silently.</li> </ul>"},{"location":"user/nd_execution_model/#how-bijux-vex-handles-it","title":"How Bijux-Vex handles it","text":"<p>ND (non-deterministic) execution is an explicit mode with declared randomness, bounded quality, and refusal when bounds are violated.</p>"},{"location":"user/nd_execution_model/#what-trade-offs-remain","title":"What trade-offs remain","text":"<ul> <li>ND is not bit-replayable.</li> <li>Higher quality usually costs latency.</li> </ul>"},{"location":"user/nd_execution_model/#where-to-go-deeper","title":"Where to go deeper","text":"<ul> <li><code>docs/user/nd_quality_confidence.md</code></li> <li><code>docs/user/nd_reproducibility.md</code></li> <li><code>docs/user/nd_parameters.md</code></li> </ul> <p>ND planning</p> <ul> <li>Selects a runner based on capabilities and configuration.</li> <li>Resolves parameters from explicit profiles or tuning output.</li> <li>Applies budgets and refusal rules before execution.</li> </ul> <p>Runner selection</p> <ul> <li>The system chooses the best available ND runner.</li> <li>If no runner can satisfy the requested capabilities, ND refuses.</li> </ul> <p>Parameters and budgets</p> <ul> <li>Parameters are explicit or resolved from profiles.</li> <li>Budgets bound latency, memory, and candidate exploration.</li> </ul> <p>Degradation and refusal</p> <ul> <li>ND may degrade only through explicit policies.</li> <li>If bounds are exceeded or determinism rules are violated, ND refuses.</li> </ul>"},{"location":"user/nd_execution_model/#common-misunderstandings","title":"Common misunderstandings","text":"<ul> <li>\u201cND is just faster exact.\u201d It is approximate and must be treated as such.</li> <li>\u201cSeeds make ND deterministic.\u201d Seeds help but do not replace bounds.</li> <li>\u201cND doesn\u2019t need provenance.\u201d ND needs provenance even more.</li> </ul>"},{"location":"user/nd_failure_story/","title":"ND Failure Story","text":"<p>A product team switches to ANN for scale. Latency improves, but recommendations become unstable. Users notice inconsistent results, and the team can\u2019t reproduce the issue.</p> <p>The root cause is an undeclared randomness source and a drifting index. With Bijux\u2011Vex, ND would have required explicit randomness declarations, recorded the index hash, and flagged the drift early.</p>"},{"location":"user/nd_metrics_intuition/","title":"ND Quality Metrics \u2014 Intuitive Guide","text":"<p>Rank instability</p> <ul> <li>Question it answers: \u201cWould the order change if I reran this?\u201d</li> <li>Good value: close to zero.</li> <li>If bad: enable witness mode or raise recall.</li> </ul> <p>Distance margin</p> <ul> <li>Question it answers: \u201cHow separated are the top results?\u201d</li> <li>Good value: larger margins feel safer.</li> <li>If bad: lower <code>k</code> or switch to exact for verification.</li> </ul> <p>Similarity entropy</p> <ul> <li>Question it answers: \u201cAre the results all basically the same?\u201d</li> <li>Good value: moderate entropy (not uniform noise).</li> <li>If bad: tune parameters or review the corpus quality.</li> </ul>"},{"location":"user/nd_parameters/","title":"Choosing ND Parameters Without Being an ANN Expert","text":""},{"location":"user/nd_parameters/#why-this-exists","title":"Why this exists","text":"<p>ANN parameters are easy to get wrong. This section gives you safe, human-scale choices so you can move fast without becoming an ANN specialist.</p> <p>If you skip this, you may ship results that are too slow, too unstable, or too low-quality for your use case.</p>"},{"location":"user/nd_parameters/#story-scenario","title":"Story / scenario","text":"<p>A team turns on ANN with default parameters. Latency improves, but recall drops and nobody notices until users complain. A profile or target recall would have caught this.</p>"},{"location":"user/nd_parameters/#what-usually-goes-wrong","title":"What usually goes wrong","text":"<ul> <li>Teams copy parameters from unrelated benchmarks.</li> <li>Budgets are set without understanding the trade-offs.</li> </ul>"},{"location":"user/nd_parameters/#how-bijux-vex-handles-it","title":"How Bijux-Vex handles it","text":"<p>Use explicit profiles and budgets to control ND behavior safely.</p>"},{"location":"user/nd_parameters/#what-trade-offs-remain","title":"What trade-offs remain","text":"<ul> <li>Better quality usually costs more latency.</li> <li>Lower budgets may trigger refusals.</li> </ul>"},{"location":"user/nd_parameters/#where-to-go-deeper","title":"Where to go deeper","text":"<ul> <li><code>docs/user/nd_decision_tree.md</code></li> <li><code>docs/user/nd_quality_confidence.md</code></li> </ul> <p>Profiles</p> <ul> <li><code>fast</code>: minimize latency, lower recall.</li> <li><code>balanced</code>: default tradeoff.</li> <li><code>accurate</code>: higher recall with more work.</li> </ul> <p>Latency budget</p> <ul> <li>Use <code>nd.latency_budget_ms</code> to bound query time.</li> <li>ND refuses if it cannot meet the budget with the chosen profile.</li> </ul> <p>Target recall</p> <ul> <li>Use <code>nd.target_recall</code> when you care about quality.</li> <li>If the backend cannot honor the target, ND refuses or degrades with explicit reporting.</li> </ul> <p>When to tune</p> <ul> <li>Use <code>bijux vex nd tune</code> on a representative dataset.</li> <li>Apply the recommended config in your <code>bijux_vex.toml</code>.</li> </ul> <p>When to refuse</p> <ul> <li>If you cannot declare a seed or randomness sources.</li> <li>If budget and target recall are incompatible.</li> </ul>"},{"location":"user/nd_promises/","title":"What ND Can and Cannot Promise","text":""},{"location":"user/nd_promises/#why-this-exists","title":"Why this exists","text":"<p>ND is powerful but only safe when its limits are explicit. This page exists to set expectations before you rely on ND in production.</p>"},{"location":"user/nd_promises/#what-nd-optimizes-for","title":"What ND optimizes for","text":"<ul> <li>Speed at scale</li> <li>Bounded quality with explicit metrics</li> <li>Transparent uncertainty</li> </ul>"},{"location":"user/nd_promises/#what-nd-cannot-guarantee","title":"What ND cannot guarantee","text":"<ul> <li>Bit\u2011identical replay</li> <li>Exact ranking agreement with deterministic search</li> <li>Stability without fixed index hashes and parameters</li> </ul>"},{"location":"user/nd_promises/#what-replaces-guarantees","title":"What replaces guarantees","text":"<ul> <li>Quality metrics (instability, margin, entropy)</li> <li>Witness checks when enabled</li> <li>Declared randomness profiles and bounds</li> </ul>"},{"location":"user/nd_quality_confidence/","title":"ND Quality &amp; Confidence","text":""},{"location":"user/nd_quality_confidence/#why-this-exists","title":"Why this exists","text":"<p>ND quality metrics tell you whether the results are stable enough to use. Without them, you might ship low-quality results that look fine in development but fail in production.</p> <p>This section is for anyone who needs to make operational decisions about ND quality\u2014engineers, analysts, and on-call responders.</p>"},{"location":"user/nd_quality_confidence/#story-scenario","title":"Story / scenario","text":"<p>A recommendation model drifts after a data update. Metrics reveal a spike in instability, and the team rolls back before users notice.</p>"},{"location":"user/nd_quality_confidence/#what-usually-goes-wrong","title":"What usually goes wrong","text":"<ul> <li>Teams treat ANN results as \u201cgood enough\u201d without measuring.</li> <li>Confidence labels are not used to gate downstream behavior.</li> </ul>"},{"location":"user/nd_quality_confidence/#how-bijux-vex-handles-it","title":"How Bijux-Vex handles it","text":"<p>ND results include quality metrics and a confidence label so downstream systems can act safely.</p>"},{"location":"user/nd_quality_confidence/#what-trade-offs-remain","title":"What trade-offs remain","text":"<ul> <li>Measuring quality costs time.</li> <li>Witness checks can be expensive at scale.</li> </ul>"},{"location":"user/nd_quality_confidence/#where-to-go-deeper","title":"Where to go deeper","text":"<ul> <li><code>docs/user/nd_examples.md</code></li> <li><code>docs/user/nd_decision_tree.md</code></li> </ul> <p>Quality metrics</p> <ul> <li>Rank instability: how sensitive the ordering is.</li> <li>Distance margin: how separated the top-k neighbors are.</li> <li>Similarity entropy: how uniform the scores are.</li> </ul> <p>Witness modes</p> <ul> <li><code>off</code>: no witness check, metrics reported as not measured.</li> <li><code>sample</code>: exact verification on a small subset.</li> <li><code>full</code>: exact verification on full candidates.</li> </ul> <p>Confidence labels</p> <ul> <li><code>high_confidence</code>: stable ranking and clear margins.</li> <li><code>medium_confidence</code>: acceptable variance.</li> <li><code>low_confidence</code>: unstable or low-signal results.</li> </ul> <p>What to do with low confidence</p> <ul> <li>Reduce <code>k</code> or increase recall targets.</li> <li>Enable witness mode.</li> <li>Switch to deterministic exact for verification.</li> </ul> <p>Example ND report (simplified)</p> <pre><code>{\n  \"quality\": {\n    \"rank_instability\": 0.12,\n    \"distance_margin\": 0.45,\n    \"similarity_entropy\": 0.62\n  },\n  \"confidence\": \"medium_confidence\",\n  \"witness\": \"sample\"\n}\n</code></pre>"},{"location":"user/nd_quality_confidence/#common-misunderstandings","title":"Common misunderstandings","text":"<ul> <li>\u201cConfidence is subjective.\u201d It is derived from explicit metrics.</li> <li>\u201cLow confidence means failure.\u201d It means you should verify or adjust.</li> <li>\u201cMetrics are optional.\u201d They are required for ND safety.</li> </ul>"},{"location":"user/nd_reproducibility/","title":"ND Reproducibility (Honest Version)","text":""},{"location":"user/nd_reproducibility/#why-this-exists","title":"Why this exists","text":"<p>ND is powerful but can be misleading if people assume replay means exact equality. This doc explains what ND can replay and what it cannot so teams don\u2019t build false guarantees into their systems.</p> <p>If you skip this, you risk audits that can\u2019t be reproduced and decisions based on unstable results.</p>"},{"location":"user/nd_reproducibility/#story-scenario","title":"Story / scenario","text":"<p>An incident review asks, \u201cWhy did the system show those results?\u201d Without ND reproducibility bounds, the answer is guesswork.</p>"},{"location":"user/nd_reproducibility/#what-usually-goes-wrong","title":"What usually goes wrong","text":"<ul> <li>Seeds are omitted.</li> <li>Index hashes drift without being noticed.</li> <li>ND runs are treated as deterministic.</li> </ul>"},{"location":"user/nd_reproducibility/#how-bijux-vex-handles-it","title":"How Bijux-Vex handles it","text":"<p>ND can be reproducible within bounds, but it is not deterministic. Reproducibility depends on index hash, parameters, and randomness declarations.</p>"},{"location":"user/nd_reproducibility/#what-trade-offs-remain","title":"What trade-offs remain","text":"<ul> <li>Replay may be refused if bounds are not met.</li> <li>Some backends cannot seed fully.</li> </ul>"},{"location":"user/nd_reproducibility/#where-to-go-deeper","title":"Where to go deeper","text":"<ul> <li><code>docs/user/nd_parameters.md</code></li> <li><code>docs/user/nd_execution_model.md</code></li> </ul> <p>What can be replayed</p> <ul> <li>ND executions with explicit seeds and stable index hashes.</li> <li>ND runs with replayable bounds declared in provenance.</li> </ul> <p>What cannot be replayed</p> <ul> <li>Runs without explicit randomness declarations.</li> <li>Runs where index hash or parameters drift.</li> </ul> <p>Role of seeds</p> <ul> <li>If a runner supports seeding, the seed is mandatory for replay.</li> <li>If a runner cannot seed, the execution is marked non-replayable.</li> </ul> <p>Index hashes</p> <ul> <li>ND replay requires matching index hash and corpus fingerprint.</li> <li>If hashes differ, replay is refused with a structured payload.</li> </ul> <p>Reproducibility bounds</p> <ul> <li>ND provenance reports expected overlap or instability bounds.</li> <li>These bounds are the contract, not bit-identical equality.</li> </ul>"},{"location":"user/nd_reproducibility/#common-misunderstandings","title":"Common misunderstandings","text":"<ul> <li>\u201cND replay is the same as deterministic replay.\u201d It is not.</li> <li>\u201cA seed guarantees identical results.\u201d It only helps within bounds.</li> <li>\u201cReproducibility is optional.\u201d It must be declared explicitly.</li> </ul>"},{"location":"user/nd_terminology/","title":"ND Terminology (Canonical)","text":"<p>Use this phrase consistently:</p> <p>Non\u2011Deterministic (ND) execution</p> <p>Avoid mixing terms like \u201capproximate,\u201d \u201cANN,\u201d or \u201cnon\u2011deterministic\u201d without the ND framing. ANN is a technique used by ND execution.</p>"},{"location":"user/nd_troubleshooting/","title":"ND Troubleshooting","text":""},{"location":"user/nd_troubleshooting/#why-this-exists","title":"Why this exists","text":"<p>When ND fails, it often fails in ways that look like \u201cbad search.\u201d This guide helps you diagnose and fix the real cause quickly.</p> <p>If you skip this, you can waste time tuning the wrong knobs or blaming your data.</p>"},{"location":"user/nd_troubleshooting/#story-scenario","title":"Story / scenario","text":"<p>An ops team sees rising latency and unstable results after a deployment. The issue is an index drift and an overly strict budget.</p>"},{"location":"user/nd_troubleshooting/#what-usually-goes-wrong","title":"What usually goes wrong","text":"<ul> <li>Index drift after ingest changes.</li> <li>Budgets set without realistic expectations.</li> <li>Backend outages mistaken for quality issues.</li> </ul>"},{"location":"user/nd_troubleshooting/#how-bijux-vex-handles-it","title":"How Bijux-Vex handles it","text":"<p>ND exposes explicit refusal reasons and quality metrics so you can pinpoint the issue.</p>"},{"location":"user/nd_troubleshooting/#what-trade-offs-remain","title":"What trade-offs remain","text":"<ul> <li>Some fixes require rebuilds or higher budgets.</li> <li>Some instability is unavoidable at scale.</li> </ul>"},{"location":"user/nd_troubleshooting/#where-to-go-deeper","title":"Where to go deeper","text":"<ul> <li><code>docs/user/nd_quality_confidence.md</code></li> <li><code>docs/user/nd_parameters.md</code></li> </ul> <p>Low recall</p> <ul> <li>Increase <code>nd.target_recall</code> or use <code>accurate</code> profile.</li> <li>Enable witness mode to validate quality.</li> </ul> <p>High latency</p> <ul> <li>Reduce candidate limits or use <code>fast</code> profile.</li> <li>Lower <code>top_k</code> if possible.</li> </ul> <p>Unstable results</p> <ul> <li>Provide an explicit seed.</li> <li>Ensure index hash and parameters are stable across runs.</li> </ul> <p>Backend unavailable</p> <ul> <li>Check <code>bijux vex vdb status</code>.</li> <li>Verify backend installation and credentials.</li> </ul> <p>Index drift</p> <ul> <li>Rebuild the ND index.</li> <li>Ensure corpus fingerprint matches the artifact.</li> </ul>"},{"location":"user/nd_trust_checklist/","title":"ND Trust Checklist","text":"<p>Before using ND in production:</p> <ul> <li>Budgets are set (latency, memory, candidates).</li> <li>Witness mode is enabled (<code>sample</code> or <code>full</code>).</li> <li>Confidence labels are checked before downstream actions.</li> <li>A deterministic fallback path exists.</li> <li>Provenance is retained.</li> </ul>"},{"location":"user/nd_use_cases/","title":"ND Starts With Use Cases","text":"<p>ND is not a warning label. It is how you make large\u2011scale retrieval practical.</p> <p>Use cases</p> <ul> <li>Search at scale (when exact is too slow)</li> <li>Recommendations (when small ranking drift is acceptable)</li> <li>Clustering and similarity exploration</li> <li>RAG retrieval (fast candidate generation)</li> <li>Anomaly detection (approximate neighbors at scale)</li> </ul> <p>ND is safe when its bounds are explicit and monitored.</p>"},{"location":"user/not_a_vdb/","title":"bijux-vex is not a vector DB","text":"<p>bijux-vex is an execution engine, not a storage system. It does not provide vector DB semantics by default.</p>"},{"location":"user/not_a_vdb/#what-it-is-not","title":"What it is not","text":"<ul> <li>No storage contract: the execution ledger is provenance, not a database.</li> <li>No serving guarantees: latency/availability are not SLAs; budgets are for experiments.</li> <li>No CRUD API beyond ingestion for execution-scoped artifacts.</li> <li>Determinism and nondeterminism are execution contracts, not storage modes.</li> </ul>"},{"location":"user/not_a_vdb/#what-it-can-integrate-with-explicitly","title":"What it can integrate with (explicitly)","text":"<ul> <li>External vector stores can be wired in only via explicit opt-in.</li> <li>There is no silent persistence or implicit vector store selection.</li> <li>If you need multi-tenant storage, use a vector DB and run bijux-vex for audited execution only.</li> </ul>"},{"location":"user/not_a_vdb/#replay-clarity","title":"Replay clarity","text":"<ul> <li>ANN replay is not equality: ND executions record envelopes and audit; replay validates envelopes, not ANN equality.</li> </ul>"},{"location":"user/only_read_one_page/","title":"If You Only Read One Page, Read This","text":"<p>Bijux-Vex exists because correctness breaks quietly in real systems. A search result that changes between runs can trigger wrong decisions, broken audits, or production incidents that take weeks to explain. Bijux-Vex protects you from that kind of invisible drift.</p> <p>The system chooses correctness over convenience on purpose. It refuses to guess, refuses to hide uncertainty, and refuses to pretend that approximation is exact. This is not stubbornness\u2014it is a safety feature. If you need a clear audit trail or you need to know when your results can be trusted, you want a system that says \u201cno\u201d at the right time.</p> <p>Refusals exist because silence is dangerous. When a backend can\u2019t meet the contract, a refusal makes the problem visible immediately\u2014before it becomes a costly incident. ND (non-deterministic) execution is treated carefully for the same reason: it is powerful, but only safe when its limits are explicit.</p> <p>If you want a system that tells the truth about its guarantees, Bijux-Vex is for you.</p>"},{"location":"user/operator_guide/","title":"Operator Guide","text":"<p>This guide covers production operations for Bijux Vex.</p>"},{"location":"user/operator_guide/#running-fastapi","title":"Running FastAPI","text":"<ul> <li>Use a process manager (systemd, container runtime) with <code>uvicorn</code>.</li> <li>Example: <code>uvicorn bijux_vex.boundaries.api.app:app --host 0.0.0.0 --port 8000</code></li> <li>Configure workers based on CPU cores and expected concurrency.</li> </ul>"},{"location":"user/operator_guide/#config-env-patterns","title":"Config + Env Patterns","text":"<ul> <li>Prefer explicit config files created via <code>bijux vex init</code>.</li> <li>Use <code>BIJUX_VEX_STATE_PATH</code> and <code>BIJUX_VEX_RUN_DIR</code> to isolate storage per service.</li> <li>Avoid implicit vector store selection; set <code>vector_store.backend</code> explicitly.</li> </ul>"},{"location":"user/operator_guide/#safe-logging","title":"Safe Logging","text":"<ul> <li>Use <code>BIJUX_VEX_LOG_FORMAT=json</code> for structured logs.</li> <li>Never log raw URIs with credentials; redaction is enforced on vector store URIs.</li> </ul>"},{"location":"user/operator_guide/#scaling-guidance","title":"Scaling Guidance","text":"<ul> <li>Increase workers for request concurrency.</li> <li>Keep vector store backend local for low latency; use Qdrant for remote scaling.</li> <li>Use <code>resource_limits</code> to prevent abusive requests.</li> </ul>"},{"location":"user/plugin_author_guide/","title":"Plugin Author Guide","text":""},{"location":"user/plugin_author_guide/#template-layout","title":"Template Layout","text":"<pre><code>template_plugin/\n  pyproject.toml\n  src/\n    bijux_vex_plugin_example/\n      __init__.py\n  tests/\n    test_plugin_contracts.py\n</code></pre>"},{"location":"user/plugin_author_guide/#entry-points","title":"Entry Points","text":"<p>Register entrypoints under:</p> <ul> <li><code>bijux_vex.vectorstores</code></li> <li><code>bijux_vex.embeddings</code></li> <li><code>bijux_vex.runners</code></li> </ul>"},{"location":"user/plugin_author_guide/#test-kit","title":"Test Kit","text":"<p>Run the plugin test kit:</p> <pre><code>python scripts/plugin_test_kit.py --format json\n</code></pre>"},{"location":"user/plugin_author_guide/#minimal-contract-requirements","title":"Minimal Contract Requirements","text":"<ul> <li>Declare determinism.</li> <li>Declare randomness sources.</li> <li>Declare approximation behavior.</li> </ul>"},{"location":"user/project_values/","title":"Project Values","text":"<ul> <li>Correctness over convenience</li> <li>Explicit over implicit</li> <li>Honest failure over silent success</li> </ul>"},{"location":"user/provenance_audit/","title":"Provenance as an Audit Narrative","text":""},{"location":"user/provenance_audit/#why-this-exists","title":"Why this exists","text":"<p>When something goes wrong, \u201cthe system said so\u201d is not an explanation. Provenance tells you what happened, why it happened, and what was refused so you can defend your results.</p> <p>Without provenance, incidents become guesswork. With it, you have evidence.</p>"},{"location":"user/provenance_audit/#story-scenario","title":"Story / scenario","text":"<p>A customer asks why results changed between two runs. Provenance shows the exact index hash, configuration, and randomness declaration that changed.</p>"},{"location":"user/provenance_audit/#what-usually-goes-wrong","title":"What usually goes wrong","text":"<ul> <li>Provenance is treated as optional logging.</li> <li>Results are stored without the plan that produced them.</li> </ul>"},{"location":"user/provenance_audit/#how-bijux-vex-handles-it","title":"How Bijux-Vex handles it","text":"<p>Provenance is emitted for every execution and includes the decisions and artifacts needed to audit results.</p>"},{"location":"user/provenance_audit/#what-trade-offs-remain","title":"What trade-offs remain","text":"<ul> <li>Provenance adds storage overhead.</li> <li>Some details require careful redaction.</li> </ul>"},{"location":"user/provenance_audit/#where-to-go-deeper","title":"Where to go deeper","text":"<ul> <li><code>docs/user/failure_modes_safety.md</code></li> <li><code>docs/user/deterministic_replay.md</code></li> </ul> <p>Structure</p> <ul> <li>Inputs: vectors, documents, and configuration.</li> <li>Decisions: runner selection, budgets, parameters.</li> <li>Randomness: seeds and declared sources.</li> <li>Artifacts: index hash, corpus fingerprint, and execution IDs.</li> </ul> <p>How to store</p> <ul> <li>Treat provenance as immutable audit data.</li> <li>Store alongside results and configuration snapshots.</li> </ul> <p>How to compare</p> <ul> <li>Compare fingerprints to verify deterministic replay.</li> <li>Compare ND quality metrics to track stability over time.</li> </ul> <p>Retention strategies</p> <ul> <li>Keep provenance for all production runs.</li> <li>For large volumes, store summaries and reference full artifacts by ID.</li> </ul> <p>How provenance answers \u201cwhy did this happen?\u201d</p> <ul> <li>It records the exact plan and parameters used.</li> <li>It shows whether any degradation or refusal occurred.</li> </ul>"},{"location":"user/provenance_audit/#common-misunderstandings","title":"Common misunderstandings","text":"<ul> <li>\u201cProvenance is just logs.\u201d It is structured, queryable evidence.</li> <li>\u201cProvenance is optional.\u201d It is a core contract.</li> <li>\u201cIt\u2019s too verbose to use.\u201d Summaries can be stored while full data is retained.</li> </ul>"},{"location":"user/reading_order/","title":"Reading Order","text":"<p>If you are new</p> <ul> <li><code>docs/user/what_is_bijux_vex.md</code></li> <li><code>docs/user/start_here.md</code></li> <li><code>docs/overview/architecture_walkthrough.md</code></li> <li><code>docs/user/determinism_end_to_end.md</code></li> <li><code>docs/user/nd_execution_model.md</code></li> </ul> <p>If you are an operator</p> <ul> <li><code>docs/user/operator_guide.md</code></li> <li><code>docs/user/failure_modes_safety.md</code></li> <li><code>docs/user/provenance_audit.md</code></li> <li><code>docs/user/trust_model.md</code></li> <li><code>docs/user/troubleshooting.md</code></li> </ul> <p>If you are extending ND</p> <ul> <li><code>docs/contracts/nd_contract_v1.md</code></li> <li><code>docs/user/nd_execution_model.md</code></li> <li><code>docs/user/nd_parameters.md</code></li> <li><code>docs/user/nd_quality_confidence.md</code></li> <li><code>docs/user/nd_reproducibility.md</code></li> </ul>"},{"location":"user/release_notes_narrative/","title":"Release Narrative (v0.2, draft)","text":"<p>v0.2 turns Bijux\u2011Vex into a system you can trust in production. It formalizes deterministic replay, makes ND bounded and auditable, and pushes \u201cnothing implicit\u201d deeper into the CLI, API, and provenance.</p> <p>Compared to v0.1, v0.2 is not just more features\u2014it is more explicit. It tells you when a guarantee is real, when it is bounded, and when it cannot be met.</p>"},{"location":"user/safety_philosophy/","title":"Safety Philosophy","text":"<p>Bijux-Vex is built to fail closed, not fail quietly.</p> <p>Refusal is a feature</p> <ul> <li>If a guarantee cannot be met, the system refuses instead of guessing.</li> <li>Refusal makes problems visible early, when they are cheaper to fix.</li> </ul> <p>Fail-closed design</p> <ul> <li>Non-determinism is never implicit.</li> <li>Backends never silently downgrade capabilities.</li> <li>Partial writes are treated as invalid until proven complete.</li> </ul> <p>Why silence is dangerous</p> <ul> <li>Silent fallbacks create false confidence.</li> <li>Hidden approximation makes audits meaningless.</li> <li>Undeclared randomness turns production into guesswork.</li> </ul> <p>This philosophy is why Bijux-Vex feels strict. It is strict so you can trust it.</p>"},{"location":"user/security_guide/","title":"Security Guide","text":""},{"location":"user/security_guide/#secrets-handling","title":"Secrets Handling","text":"<ul> <li>Use environment variables or secret managers for backend credentials.</li> <li>Vector store URIs are redacted in logs and provenance.</li> </ul>"},{"location":"user/security_guide/#provenance-redaction","title":"Provenance Redaction","text":"<ul> <li><code>vector_store.uri_redacted</code> is stored instead of raw URIs.</li> <li>Bundle exports use redacted config by default.</li> </ul>"},{"location":"user/security_guide/#safe-bundle-sharing","title":"Safe Bundle Sharing","text":"<ul> <li>Bundles include provenance, config (redacted), and results.</li> <li>Vectors are excluded unless <code>--include-vectors</code> is explicitly set.</li> </ul>"},{"location":"user/security_guide/#threat-model-boundaries","title":"Threat Model Boundaries","text":"<p>Bijux Vex does not:</p> <ul> <li>Prevent malicious data in vectors or documents.</li> <li>Validate external service credentials beyond connectivity.</li> <li>Provide encryption at rest for local files.</li> </ul> <p>Bijux Vex does:</p> <ul> <li>Enforce explicit configuration for vector stores and embeddings.</li> <li>Refuse deterministic runs when determinism cannot be guaranteed.</li> </ul>"},{"location":"user/security_posture/","title":"Security Posture","text":"<p>Threat model</p> <ul> <li>Bijux\u2011Vex assumes you control the runtime environment.</li> <li>It does not protect against compromised hosts or malicious backends.</li> </ul> <p>In scope</p> <ul> <li>Redaction of credentials in logs and provenance</li> <li>Explicit failure on unsafe conditions</li> </ul> <p>Out of scope</p> <ul> <li>Data exfiltration prevention</li> <li>Encryption at rest for external stores</li> </ul> <p>Reporting issues</p> <ul> <li>See <code>SECURITY.md</code> in the repository.</li> </ul>"},{"location":"user/stability_evolution_policy/","title":"Stability &amp; Evolution Policy","text":"<p>Patch releases</p> <ul> <li>Bug fixes and documentation improvements.</li> <li>No changes to deterministic execution semantics.</li> </ul> <p>Minor releases</p> <ul> <li>New features that do not break contracts.</li> <li>ND behavior may evolve but remains explicit and auditable.</li> </ul> <p>Major releases</p> <ul> <li>Any breaking contract changes.</li> <li>Deprecated behavior removed.</li> </ul> <p>Compatibility</p> <ul> <li>Backward compatibility is treated as a default.</li> <li>Changes are documented in the changelog and compatibility docs.</li> </ul>"},{"location":"user/stability_support_policy/","title":"Stability &amp; Support Policy","text":"<ul> <li>Minor releases will not break deterministic execution or replay semantics.</li> <li>ND behavior may evolve but will remain explicit and auditable.</li> <li>Deprecated features are documented before removal.</li> </ul>"},{"location":"user/start_here/","title":"Start here \u2014 bijux-vex onboarding","text":""},{"location":"user/start_here/#what-problem-does-bijux-vex-solve","title":"What problem does bijux-vex solve?","text":"<p>Vector execution often hides determinism assumptions. bijux-vex makes execution contracts explicit, auditable, and replayable so you can compare deterministic (exact) and non-deterministic (ANN) runs side by side.</p>"},{"location":"user/start_here/#when-should-you-use-it","title":"When should you use it?","text":"<ul> <li>You need reproducible deterministic vector execution with provenance you can replay.</li> <li>You want bounded, auditable non-deterministic execution (ANN) with explicit approximation and randomness metadata.</li> <li>You care about comparing exact vs approximate results across backends and artifacts.</li> </ul>"},{"location":"user/start_here/#deterministic-vs-non-deterministic-high-level","title":"Deterministic vs non-deterministic (high level)","text":"<ul> <li>Deterministic: exact search, bit-stable, replay required. No hidden randomness.</li> <li>Non-deterministic (ANN, experimental): approximate path only, bounded divergence, emits <code>ApproximationReport</code> + <code>RandomnessProfile</code>, replay is envelope-based.</li> </ul>"},{"location":"user/start_here/#start-here-path-canonical","title":"Start here path (canonical)","text":"<p>1) CLI flow: <code>ingest</code> \u2192 <code>materialize</code> \u2192 <code>execute</code> \u2192 <code>replay</code> \u2192 <code>compare</code>. 2) Concepts: overview/concepts.md. 3) Example walkthrough: examples/overview.md.</p>"},{"location":"user/start_here/#quickstart-workflow-a","title":"Quickstart (Workflow A)","text":"<pre><code>--8&lt;-- \"docs/examples/workflows/workflow_a.sh\"\n</code></pre>"},{"location":"user/start_here/#what-to-read-next","title":"What to read next","text":"<p>1) Concepts: overview/concepts.md \u2014 mental model of execution vs storage. 2) Contracts: spec/system_contract.md and spec/execution_contracts.md. 3) Examples: examples/overview.md \u2014 deterministic and ANN flows. 4) API: api/index.md and the canonical schema api/v1/schema.yaml. 5) Not a vector DB: user/not_a_vdb.md. 6) BYO vectors vs auto-embeddings: user/byo_vectors_vs_embeddings.md.</p>"},{"location":"user/start_here_10_minutes/","title":"Start Here in 10 Minutes","text":"<p>1) Install</p> <pre><code>pip install bijux-vex\n</code></pre> <p>2) Deterministic example</p> <pre><code>bijux vex ingest --doc \"hello\" --vector \"[0.0, 1.0, 0.0]\" --vector-store memory\nbijux vex materialize --execution-contract deterministic --vector-store memory\nbijux vex execute --artifact-id art-1 --execution-contract deterministic \\\n  --execution-intent exact_validation --execution-mode strict --vector \"[0.0, 1.0, 0.0]\"\n</code></pre> <p>3) ND example</p> <pre><code>bijux vex materialize --execution-contract non_deterministic --index-mode ann \\\n  --vector-store faiss --vector-store-uri ./index.faiss\nbijux vex execute --artifact-id art-1 --execution-contract non_deterministic \\\n  --execution-intent exploratory_search --execution-mode bounded \\\n  --randomness-seed 42 --randomness-sources ann_probe --nd-witness sample \\\n  --vector \"[0.0, 1.0, 0.0]\"\n</code></pre> <p>4) Inspect provenance</p> <pre><code>bijux vex explain --result-id &lt;result_id&gt; --artifact-id art-1\n</code></pre>"},{"location":"user/start_here_human/","title":"Start Here (Human)","text":"<p>You are probably here because search results changed when they shouldn\u2019t, or because you don\u2019t trust what your vector stack is doing in production.</p> <p>Bijux\u2011Vex exists to make those failures visible and prevent silent drift. It gives you two clear execution paths:</p> <ul> <li>Deterministic: exact, replayable, and auditable.</li> <li>ND (non\u2011deterministic): fast and scalable, but bounded and explicit.</li> </ul> <p>If you only run one example, run this:</p> <pre><code>bijux vex ingest --doc \"hello\" --vector \"[0.0, 1.0, 0.0]\" --vector-store memory\nbijux vex materialize --execution-contract deterministic --vector-store memory\nbijux vex execute --artifact-id art-1 --execution-contract deterministic \\\n  --execution-intent exact_validation --execution-mode strict --vector \"[0.0, 1.0, 0.0]\"\n</code></pre> <p>Once that works, read:</p> <ul> <li><code>docs/user/what_is_bijux_vex.md</code></li> <li><code>docs/user/determinism_end_to_end.md</code></li> <li><code>docs/user/nd_execution_model.md</code></li> </ul>"},{"location":"user/troubleshooting/","title":"Troubleshooting","text":""},{"location":"user/troubleshooting/#vdb-connection-fails","title":"VDB Connection Fails","text":"<p>What happened: The vector store backend could not connect. Fix:</p> <ol> <li>Verify the backend is installed (<code>pip install \"bijux-vex[vdb]\"</code>).</li> <li>Check the URI or file path.</li> <li>Run <code>bijux vex vdb status --vector-store &lt;name&gt;</code>.</li> </ol>"},{"location":"user/troubleshooting/#ann-not-installed","title":"ANN Not Installed","text":"<p>What happened: ANN execution requested but the ANN runner is unavailable. Fix:</p> <ol> <li>Use <code>--execution-contract deterministic</code>.</li> <li>Use exact mode or install the ANN backend for your environment.</li> </ol>"},{"location":"user/troubleshooting/#embedding-provider-missing","title":"Embedding Provider Missing","text":"<p>What happened: <code>--embed-model</code> specified but provider not installed. Fix:</p> <ol> <li>Install embeddings extras: <code>pip install \"bijux-vex[embeddings]\"</code>.</li> <li>Provide a registered provider name.</li> </ol>"},{"location":"user/troubleshooting/#determinism-refused","title":"Determinism Refused","text":"<p>What happened: Deterministic contract requested with a non-deterministic backend. Fix:</p> <ol> <li>Use exact mode (<code>--execution-contract deterministic</code>).</li> <li>Avoid ANN until it is marked stable.</li> </ol>"},{"location":"user/troubleshooting/#unknown-vector-store","title":"Unknown Vector Store","text":"<p>What happened: <code>--vector-store</code> name not registered. Fix:</p> <ol> <li>Check <code>bijux vex capabilities</code>.</li> <li>Install the plugin that provides the backend.</li> </ol>"},{"location":"user/trust_and_guarantees/","title":"Trust &amp; Guarantees","text":"<p>Hard guarantees</p> <ul> <li>Deterministic execution is exact and replayable.</li> <li>Canonical ordering applies to deterministic results.</li> <li>Provenance is emitted for every execution.</li> </ul> <p>Bounded guarantees</p> <ul> <li>ND quality is bounded by explicit metrics.</li> <li>ND replay is possible only within declared bounds.</li> </ul> <p>Explicit non\u2011guarantees</p> <ul> <li>Cross\u2011backend numeric equality beyond the query contract.</li> <li>Implicit fallbacks or hidden approximation.</li> <li>\u201cBest effort\u201d determinism.</li> </ul>"},{"location":"user/trust_model/","title":"Trust Model &amp; Guarantees","text":"<p>Bijux-Vex separates hard guarantees from best-effort behavior. When a guarantee cannot be met, the system refuses instead of guessing.</p> <p>Hard guarantees</p> <ul> <li>Deterministic execution is exact, replayable, and stable.</li> <li>Canonical ordering rules apply to deterministic results.</li> <li>Provenance is always emitted for executed requests.</li> <li>Refusals are explicit and structured.</li> </ul> <p>Best-effort behavior</p> <ul> <li>ND quality depends on the selected runner, parameters, and index state.</li> <li>ND witness verification is optional and may be partial.</li> <li>Backend availability and performance depend on external systems.</li> </ul> <p>Not guaranteed</p> <ul> <li>Cross-backend numeric equivalence beyond the defined query contract.</li> <li>Near-zero latency for ND under heavy load.</li> <li>Implicit retries or silent fallbacks when backends fail.</li> </ul> <p>How refusal protects correctness</p> <ul> <li>If a backend lacks required capabilities, the system refuses.</li> <li>If ND cannot honor replay or determinism bounds, the system refuses.</li> <li>If budgets would be exceeded, the system refuses rather than degrade silently.</li> </ul> <p>This trust model is designed so teams can approve adoption without hidden behavior.</p>"},{"location":"user/tutorial/","title":"End-to-End Tutorial","text":"<p>This tutorial is fully copy/pasteable. It shows an explicit, deterministic flow and an explicit VDB flow.</p>"},{"location":"user/tutorial/#install","title":"Install","text":"<pre><code>pip install bijux-vex\n</code></pre> <p>Optional extras:</p> <pre><code>pip install \"bijux-vex[embeddings]\"\npip install \"bijux-vex[vdb]\"\n</code></pre>"},{"location":"user/tutorial/#workflow-a-byo-vectors","title":"Workflow A (BYO Vectors)","text":"<pre><code>--8&lt;-- \"docs/examples/workflows/workflow_a.sh\"\n</code></pre>"},{"location":"user/tutorial/#workflow-b-docs-only-faiss","title":"Workflow B (Docs-Only + FAISS)","text":"<pre><code>--8&lt;-- \"docs/examples/workflows/workflow_b.sh\"\n</code></pre>"},{"location":"user/tutorial/#workflow-c-ann-bounded-explain","title":"Workflow C (ANN Bounded + Explain)","text":"<pre><code>--8&lt;-- \"docs/examples/workflows/workflow_c.sh\"\n</code></pre>"},{"location":"user/tutorial/#provenance","title":"Provenance","text":"<p>Workflow C includes <code>--explain</code> to show provenance output inline.</p>"},{"location":"user/v0_2_user_contract/","title":"v0.2 User Contract (Human)","text":"<p>This is the plain\u2011language contract for v0.2. It is not legal. It is a promise about behavior.</p> <p>Guaranteed</p> <ul> <li>Deterministic execution is exact and replayable.</li> <li>Canonical ordering rules apply to deterministic results.</li> <li>Provenance is emitted for every execution.</li> <li>Refusals are explicit and structured.</li> </ul> <p>Bounded</p> <ul> <li>Non\u2011Deterministic (ND) execution is approximate but audited with metrics.</li> <li>ND replay is possible only within declared bounds.</li> <li>Performance depends on the selected backend and budgets.</li> </ul> <p>Best\u2011effort</p> <ul> <li>Latency targets and throughput goals.</li> <li>Optional backend optimizations.</li> </ul> <p>Out of scope</p> <ul> <li>Acting as a vector database.</li> <li>Managing LLM orchestration or RAG pipelines.</li> <li>Silent fallbacks or implicit behavior.</li> </ul>"},{"location":"user/vector_store_semantics/","title":"Vector Store Semantics","text":""},{"location":"user/vector_store_semantics/#why-this-exists","title":"Why this exists","text":"<p>Vector stores look like databases, but they behave very differently. This section helps you avoid the most common operational mistakes\u2014especially around deletion, consistency, and replay.</p> <p>If you treat a vector store like a full database, you can end up with stale results, broken audits, or silent failures. This section is for anyone wiring storage into production systems.</p>"},{"location":"user/vector_store_semantics/#story-scenario","title":"Story / scenario","text":"<p>A team deletes records in a vector store and assumes they are gone. Weeks later, the same vectors appear again after a restart because deletes were not persisted.</p>"},{"location":"user/vector_store_semantics/#what-usually-goes-wrong","title":"What usually goes wrong","text":"<ul> <li>Deletes are treated like database deletes.</li> <li>ANN indices are assumed to update automatically.</li> <li>Consistency is assumed without checking.</li> </ul>"},{"location":"user/vector_store_semantics/#how-bijux-vex-handles-it","title":"How Bijux-Vex handles it","text":"<p>Vector stores are adapters with explicit capabilities. Bijux-Vex does not assume database semantics.</p>"},{"location":"user/vector_store_semantics/#what-trade-offs-remain","title":"What trade-offs remain","text":"<ul> <li>Some backends require rebuilds for safe deletes.</li> <li>Remote stores may be eventual rather than read-after-write.</li> </ul>"},{"location":"user/vector_store_semantics/#where-to-go-deeper","title":"Where to go deeper","text":"<ul> <li><code>docs/user/vectorstores/faiss.md</code></li> <li><code>docs/user/vectorstores/qdrant.md</code></li> </ul> <p>Exact vs ANN</p> <ul> <li>Exact search is deterministic and replayable.</li> <li>ANN is ND and must declare randomness and bounds.</li> </ul> <p>Delete semantics</p> <ul> <li>Deletes must be persisted or explicitly refused.</li> <li>If a backend cannot guarantee delete semantics, the operation fails.</li> </ul> <p>Rebuild and compaction</p> <ul> <li>Some backends require rebuild after deletes.</li> <li>Compaction is explicit and never implicit.</li> </ul> <p>Consistency guarantees</p> <ul> <li>Local stores are typically read-after-write consistent.</li> <li>Remote stores may be eventual; this is recorded in capabilities and provenance.</li> </ul> <p>Backend differences</p> <ul> <li>FAISS: local, fast, exact and ANN depending on index type.</li> <li>Qdrant: remote, supports filters and ANN, may be eventual.</li> <li>Memory/SQLite: deterministic exact only.</li> </ul>"},{"location":"user/vector_store_semantics/#common-misunderstandings","title":"Common misunderstandings","text":"<ul> <li>\u201cDeletes are always permanent.\u201d They are not unless the backend guarantees it.</li> <li>\u201cANN and exact are interchangeable.\u201d They are not.</li> <li>\u201cConsistency is implicit.\u201d It must be checked and declared.</li> </ul>"},{"location":"user/what_happens_when_things_go_wrong/","title":"What Happens If Things Go Wrong?","text":"<p>Crashes</p> <ul> <li>Incomplete runs are marked invalid and excluded from replay and compare.</li> <li>Artifacts written partially are refused on load.</li> </ul> <p>Partial writes</p> <ul> <li>Atomic write strategy prevents partial state from being treated as valid.</li> <li>If partial state is detected, execution refuses and explains why.</li> </ul> <p>Backend outages</p> <ul> <li>Requests fail fast with structured error payloads.</li> <li>Circuit breakers stop repeated failures from cascading.</li> </ul> <p>ND failures</p> <ul> <li>ND refuses when bounds cannot be met.</li> <li>Witness failures are recorded in provenance.</li> </ul>"},{"location":"user/what_is_bijux_vex/","title":"What Bijux-Vex Is (and Is Not)","text":"<p>Bijux-Vex is a vector execution system. It gives you a strict, auditable way to run vector search with hard determinism contracts, explicit non-determinism (ND) bounds, and first-class provenance. It is built for correctness, replay, and refusal when guarantees cannot be met.</p> <p>What it solves</p> <ul> <li>Deterministic vector execution with verifiable replay.</li> <li>Explicit non-deterministic (ND) execution with bounded guarantees.</li> <li>Provenance you can use for audit, debugging, and comparison.</li> <li>Vector-store routing that is explicit, inspectable, and contract-safe.</li> </ul> <p>What it intentionally refuses to do</p> <ul> <li>Implicitly choose backends, embeddings, or persistence.</li> <li>Mask non-determinism behind \u201cbest effort.\u201d</li> <li>Provide silent fallbacks when a capability is missing.</li> </ul> <p>How it differs from vector DBs</p> <ul> <li>Bijux-Vex is not a database. It does not promise CRUD semantics, query languages, or availability guarantees.</li> <li>It treats storage as a pluggable adapter and makes capability differences explicit.</li> </ul> <p>How it differs from RAG frameworks</p> <ul> <li>Bijux-Vex is not an application framework. It does not manage prompt templates, retrieval pipelines, or LLM orchestration.</li> <li>It focuses on the execution contract and provenance, not end-to-end UX.</li> </ul> <p>How it differs from ML pipelines</p> <ul> <li>Bijux-Vex is not a training or feature pipeline.</li> <li>It does not manage model lifecycle, training data, or inference services.</li> </ul> <p>When not to use Bijux-Vex</p> <ul> <li>If you need a general-purpose vector database with rich filtering and schema management.</li> <li>If you want an end-to-end RAG stack or LLM framework.</li> <li>If you are fine with \u201cprobably correct\u201d results and don\u2019t need auditability.</li> </ul> <p>If you need contractual correctness, explicit ND behavior, and provenance you can defend, Bijux-Vex is the right tool.</p>"},{"location":"user/who_should_use/","title":"Who Should Use This","text":"<p>Good fit</p> <ul> <li>Infra engineers who need reproducible search behavior.</li> <li>ML platform teams who need auditability.</li> <li>Compliance\u2011sensitive orgs that must explain results.</li> </ul> <p>Not a fit</p> <ul> <li>Teams looking for a managed vector DB.</li> <li>Teams wanting an end\u2011to\u2011end RAG framework.</li> <li>Teams that prefer implicit convenience over explicit guarantees.</li> </ul>"},{"location":"user/why_bijux_vex_exists/","title":"Why Bijux\u2011Vex Exists","text":"<p>Vector search in production often fails silently. Rankings drift, audits don\u2019t replay, and teams can\u2019t explain why results changed. Most systems optimize for convenience, not correctness.</p> <p>Bijux\u2011Vex exists to protect you from that silence. It makes determinism explicit, makes ND bounded, and refuses execution when guarantees are not met.</p> <p>Refusals are not obstacles\u2014they are the system telling you the truth early.</p>"},{"location":"user/workflows/","title":"Blessed Workflows","text":"<p>These are the three supported \"blessed workflows.\" Each has a single copy/paste script that runs end-to-end.</p> <p>Note: Workflows B and C require the FAISS backend (<code>pip install faiss-cpu</code>).</p>"},{"location":"user/workflows/#preflight-checks","title":"Preflight Checks","text":"<ul> <li>Validate inputs/config before ingest: <code>bijux vex validate --doc \"text\" --vector \"[0.0,1.0]\" --vector-store memory</code></li> <li>Diagnose setup: <code>bijux vex doctor --vector-store faiss --vector-store-uri index.faiss</code></li> </ul>"},{"location":"user/workflows/#workflow-a-byo-vectors-memory-exact-execute","title":"Workflow A: BYO Vectors \u2192 Memory \u2192 Exact Execute","text":"<pre><code>--8&lt;-- \"docs/examples/workflows/workflow_a.sh\"\n</code></pre>"},{"location":"user/workflows/#workflow-b-docs-only-explicit-embed-model-faiss-execute","title":"Workflow B: Docs-Only \u2192 Explicit Embed Model \u2192 FAISS \u2192 Execute","text":"<pre><code>--8&lt;-- \"docs/examples/workflows/workflow_b.sh\"\n</code></pre>"},{"location":"user/workflows/#workflow-c-ann-bounded-provenance-explain","title":"Workflow C: ANN Bounded \u2192 Provenance + Explain","text":"<pre><code>--8&lt;-- \"docs/examples/workflows/workflow_c.sh\"\n</code></pre>"},{"location":"user/workflows/#realistic-demo-app","title":"Realistic Demo App","text":"<pre><code>python docs/examples/demo_app.py\n</code></pre>"},{"location":"user/vectorstores/faiss/","title":"FAISS Vector Store","text":""},{"location":"user/vectorstores/faiss/#install","title":"Install","text":"<ul> <li><code>pip install bijux-vex[vdb]</code> (or <code>pip install faiss-cpu</code>)</li> </ul>"},{"location":"user/vectorstores/faiss/#connect","title":"Connect","text":"<p>Use the explicit vector store flag:</p> <pre><code>python -m bijux_vex.boundaries.cli.app ingest \\\n  --doc \"hello\" --vector \"[0.0,1.0,0.0]\" \\\n  --vector-store faiss --vector-store-uri ./index.faiss\n</code></pre>"},{"location":"user/vectorstores/faiss/#capabilities","title":"Capabilities","text":"<ul> <li>Exact search supported.</li> <li>ANN supported (experimental).</li> <li>Deletes supported (rebuild required if configured).</li> </ul>"},{"location":"user/vectorstores/faiss/#limitations","title":"Limitations","text":"<ul> <li>Filtering is not supported.</li> <li>Requires local disk for index persistence.</li> </ul>"},{"location":"user/vectorstores/faiss/#recommended-use-cases","title":"Recommended Use Cases","text":"<ul> <li>Local, single-node workloads.</li> <li>Deterministic exact execution with stable storage.</li> <li>ND experiments when ANN is explicitly configured.</li> </ul>"},{"location":"user/vectorstores/faiss/#gotchas","title":"Gotchas","text":"<ul> <li>Index parameters must match execution mode.</li> <li>Rebuild after heavy delete workloads to avoid drift.</li> </ul>"},{"location":"user/vectorstores/faiss/#operational-tips","title":"Operational Tips","text":"<ul> <li>Use <code>bijux vex vdb status</code> to inspect index metadata.</li> <li>Use <code>bijux vex vdb rebuild</code> after delete-heavy workloads.</li> </ul>"},{"location":"user/vectorstores/memory/","title":"Memory Vector Store","text":""},{"location":"user/vectorstores/memory/#install","title":"Install","text":"<ul> <li>No extras required.</li> </ul>"},{"location":"user/vectorstores/memory/#connect","title":"Connect","text":"<p>Memory is the default when no <code>--vector-store</code> is provided.</p>"},{"location":"user/vectorstores/memory/#capabilities","title":"Capabilities","text":"<ul> <li>Exact search only.</li> <li>Ephemeral (no persistence).</li> </ul>"},{"location":"user/vectorstores/memory/#limitations","title":"Limitations","text":"<ul> <li>Data is lost when the process exits.</li> <li>Not suitable for large corpora.</li> </ul>"},{"location":"user/vectorstores/memory/#recommended-use-cases","title":"Recommended Use Cases","text":"<ul> <li>Local testing and CI.</li> <li>Deterministic exact validation.</li> </ul>"},{"location":"user/vectorstores/memory/#gotchas","title":"Gotchas","text":"<ul> <li>No persistence. Replay across restarts is not possible.</li> </ul>"},{"location":"user/vectorstores/qdrant/","title":"Qdrant Vector Store","text":""},{"location":"user/vectorstores/qdrant/#install","title":"Install","text":"<ul> <li><code>pip install bijux-vex[vdb]</code> (or <code>pip install qdrant-client</code>)</li> </ul>"},{"location":"user/vectorstores/qdrant/#connect","title":"Connect","text":"<pre><code>python -m bijux_vex.boundaries.cli.app ingest \\\n  --doc \"hello\" --vector \"[0.0,1.0,0.0]\" \\\n  --vector-store qdrant --vector-store-uri http://localhost:6333\n</code></pre>"},{"location":"user/vectorstores/qdrant/#capabilities","title":"Capabilities","text":"<ul> <li>Exact and ANN supported (remote).</li> <li>Deletes supported.</li> <li>Filtering supported via adapter options.</li> </ul>"},{"location":"user/vectorstores/qdrant/#limitations","title":"Limitations","text":"<ul> <li>Requires a running Qdrant instance.</li> <li>Consistency is backend-dependent (see capabilities output).</li> </ul>"},{"location":"user/vectorstores/qdrant/#recommended-use-cases","title":"Recommended Use Cases","text":"<ul> <li>Remote, shared vector storage.</li> <li>Workloads that need filtering or metadata queries.</li> <li>ANN at scale with explicit budgets.</li> </ul>"},{"location":"user/vectorstores/qdrant/#gotchas","title":"Gotchas","text":"<ul> <li>Network latency affects ND budgets.</li> <li>Ensure credentials are redacted in logs and provenance.</li> </ul>"},{"location":"user/vectorstores/qdrant/#operational-tips","title":"Operational Tips","text":"<ul> <li>Use <code>bijux vex vdb status</code> to validate connectivity.</li> <li>Configure batch sizes and retries via adapter options.</li> </ul>"}]}